<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FractalDimensions.jl · FractalDimensions.jl</title><meta name="title" content="FractalDimensions.jl · FractalDimensions.jl"/><meta property="og:title" content="FractalDimensions.jl · FractalDimensions.jl"/><meta property="twitter:title" content="FractalDimensions.jl · FractalDimensions.jl"/><meta name="description" content="Documentation for FractalDimensions.jl."/><meta property="og:description" content="Documentation for FractalDimensions.jl."/><meta property="twitter:description" content="Documentation for FractalDimensions.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FractalDimensions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>FractalDimensions.jl</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Fractal-dimension-example"><span>Fractal dimension example</span></a></li><li><a class="tocitem" href="#Index-(contents)"><span>Index (contents)</span></a></li><li><a class="tocitem" href="#Linear-scaling-regions"><span>Linear scaling regions</span></a></li><li><a class="tocitem" href="#Generalized-(entropy)-dimension"><span>Generalized (entropy) dimension</span></a></li><li><a class="tocitem" href="#Correlation-sum-based-dimension"><span>Correlation sum based dimension</span></a></li><li><a class="tocitem" href="#Fixed-mass-correlation-sum"><span>Fixed mass correlation sum</span></a></li><li><a class="tocitem" href="#Takens-best-estimate"><span>Takens best estimate</span></a></li><li><a class="tocitem" href="#Pointwise-(local)-correlation-dimensions"><span>Pointwise (local) correlation dimensions</span></a></li><li><a class="tocitem" href="#Kaplan-Yorke-dimension"><span>Kaplan-Yorke dimension</span></a></li><li><a class="tocitem" href="#Higuchi-dimension"><span>Higuchi dimension</span></a></li><li><a class="tocitem" href="#Extreme-value-value-theory-dimensions"><span>Extreme value value theory dimensions</span></a></li><li><a class="tocitem" href="#Theiler-window"><span>Theiler window</span></a></li><li><a class="tocitem" href="#StateSpaceSet-reference"><span><code>StateSpaceSet</code> reference</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FractalDimensions.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FractalDimensions.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/FractalDimensions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FractalDimensions.jl"><a class="docs-heading-anchor" href="#FractalDimensions.jl">FractalDimensions.jl</a><a id="FractalDimensions.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FractalDimensions.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions" href="#FractalDimensions"><code>FractalDimensions</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>FractalDimensions.jl</strong></p><p><a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/fractaldimensions/dev/"><img src="https://img.shields.io/badge/docs-dev-lightblue.svg" alt/></a> <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/fractaldimensions/stable/"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://pubs.aip.org/aip/cha/article/33/10/102101/2916352/Estimating-fractal-dimensions-A-comparative-review"><img src="https://img.shields.io/badge/DOI-doi.org/10.1063/5.0160394-purple" alt/></a> <a href="https://github.com/JuliaDynamics/FractalDimensions.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDynamics/FractalDimensions.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/JuliaDynamics/FractalDimensions.jl"><img src="https://codecov.io/gh/JuliaDynamics/FractalDimensions.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://pkgs.genieframework.com?packages=FractalDimensions"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/FractalDimensions" alt="Package Downloads"/></a></p><p>A Julia package that estimates various definitions of fractal dimension from data. It can be used as a standalone package, or as part of <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a>.</p><p>To install it, run <code>import Pkg; Pkg.add(&quot;FractalDimensions&quot;)</code>.</p><p>All further information is provided in the documentation, which you can either find <a href="https://juliadynamics.github.io/FractalDimensions.jl/stable/">online</a> or build locally by running the <code>docs/make.jl</code> file.</p><p><em>Previously, this package was part of ChaosTools.jl.</em></p><p><strong>Publication</strong></p><p>FractalDimensions.jl is used in a review article comparing various estimators for fractal dimensions. The paper is likely a relevant read if you are interested in the package. And if you use the package, please cite the paper.</p><pre><code class="nohighlight hljs">@article{FractalDimensions.jl,
  doi = {10.1063/5.0160394},
  url = {https://doi.org/10.1063/5.0160394},
  year = {2023},
  month = oct,
  publisher = {{AIP} Publishing},
  volume = {33},
  number = {10},
  author = {George Datseris and Inga Kottlarz and Anton P. Braun and Ulrich Parlitz},
  title = {Estimating fractal dimensions: A comparative review and open source implementations},
  journal = {Chaos: An Interdisciplinary Journal of Nonlinear Science}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/FractalDimensions.jl#L4-L41">source</a></section></article><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package is accompanying a review paper on estimating the fractal dimension: <a href="https://arxiv.org/abs/2109.05937">https://arxiv.org/abs/2109.05937</a>. The paper is continuing the discussion of chapter 5 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p></div></div><p>There are numerous methods that one can use to calculate a so-called &quot;dimension&quot; of a dataset which in the context of dynamical systems is called the <a href="https://en.wikipedia.org/wiki/Fractal_dimension">Fractal dimension</a>. One way to do this is to estimate the <strong>scaling behaviour of some quantity as a size/scale increases</strong>. In the <a href="#Fractal-dimension-example">Fractal dimension example</a> below, one finds the scaling of the correlation sum versus a ball radius. In this case, it approximately holds $ \log(C) \approx \Delta\log(\varepsilon) $ for radius <span>$\varepsilon$</span>. The scaling of many other quantities can be estimated as well, such as the generalized entropy, the Higuchi length, or others provided here.</p><p>To actually find <span>$\Delta$</span>, one needs to find a linearly scaling region in the graph <span>$\log(C)$</span> vs. <span>$\log(\varepsilon)$</span> and estimate its slope. Hence, <strong>identifying a linear region is central to estimating a fractal dimension</strong>. That is why, the section <a href="#Linear-scaling-regions">Linear scaling regions</a> is of central importance for this documentation.</p><h2 id="Fractal-dimension-example"><a class="docs-heading-anchor" href="#Fractal-dimension-example">Fractal dimension example</a><a id="Fractal-dimension-example-1"></a><a class="docs-heading-anchor-permalink" href="#Fractal-dimension-example" title="Permalink"></a></h2><p>In this simplest example we will calculate the fractal dimension of the <a href="https://en.wikipedia.org/wiki/H%C3%A9non_map">chaotic attractor of the Hénon map</a> (for default parameters). For this example, we will generate the data on the spot:</p><pre><code class="language-julia hljs">using DynamicalSystemsBase # for simulating dynamical systems
using CairoMakie           # for plotting

henon_rule(x, p, n) = SVector(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])
u0 = zeros(2)
p0 = [1.4, 0.3]
henon = DeterministicIteratedMap(henon_rule, u0, p0)

X, t = trajectory(henon, 20_000; Ttr = 100)
scatter(X[:, 1], X[:, 2]; color = (&quot;black&quot;, 0.01), markersize = 4)</code></pre><img src="index-ed0585c9.png" alt="Example block output"/><p>instead of simulating the set <code>X</code> we could load it from disk, e.g., if there was a text file with two columns as x and y coordinates, we would load it as</p><pre><code class="language-julia hljs">using DelimitedFiles
file = &quot;path/to/file.csv&quot;
M = readdlm(file)    # here `M` is a metrix with two columns
X = StateSpaceSet(M) # important to convert to a state space set</code></pre><p>After we have <code>X</code>, we can start computing a fractal dimension and for this example we will use the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>. Our goal is to compute the correlation sum of <code>X</code> for many different sizes/radii <code>ε</code>. This is as simple as</p><pre><code class="language-julia hljs">using FractalDimensions
ες = 2 .^ (-15:0.5:5) # semi-random guess
Cs = correlationsum(X, ες; show_progress = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">41-element Vector{Float64}:
 1.8799060046997648e-6
 2.884855757212139e-6
 4.514774261286935e-6
 7.204639768011599e-6
 1.1174441277936103e-5
 1.7944102794860256e-5
 2.8333583320833955e-5
 4.5037748112594364e-5
 6.943652817359132e-5
 0.0001071696415179241
 ⋮
 0.9486205889705515
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999</code></pre><p>For a fractal set <code>X</code> dynamical systems theory says that there should be an exponential relationship between the correlation sum and the sizes:</p><pre><code class="language-julia hljs">xs = log2.(ες)
ys = log2.(Cs)
scatterlines(xs, ys; axis = (ylabel = L&quot;\log(C_2)&quot;, xlabel = L&quot;\log (\epsilon)&quot;))</code></pre><img src="index-2f9b9bd3.png" alt="Example block output"/><p>The slope of the linear scaling region of the above plot is the fractal dimension (based on the correlation sum).</p><p>Given that we <em>see</em> the plot, we can estimate where the linear scaling region starts and ends. This is generally done using <a href="#FractalDimensions.LargestLinearRegion"><code>LargestLinearRegion</code></a> in <a href="#FractalDimensions.slopefit"><code>slopefit</code></a>. But first, let&#39;s visualize what the method does, as it uses <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a>.</p><pre><code class="language-julia hljs">lrs, slopes = linear_regions(xs, ys, tol = 0.25)
fig = Figure()
ax = Axis(fig[1,1]; ylabel = L&quot;\log(C_2)&quot;, xlabel = L&quot;\log (\epsilon)&quot;)
for r in lrs
    scatterlines!(ax, xs[r], ys[r])
end
fig</code></pre><img src="index-0966a64c.png" alt="Example block output"/><p>The <a href="#FractalDimensions.LargestLinearRegion"><code>LargestLinearRegion</code></a> method finds, and computes the slope of, the largest region:</p><pre><code class="language-julia hljs">Δ = slopefit(xs, ys, LargestLinearRegion())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.2318376178087478, 1.2233720116518771, 1.2403032239656184)</code></pre><p>This result is an approximation of <em>a</em> fractal dimension.</p><p>The whole above pipeline we went through is bundled in <a href="#FractalDimensions.grassberger_proccacia_dim"><code>grassberger_proccacia_dim</code></a>. Similar work is done by <a href="#FractalDimensions.generalized_dim"><code>generalized_dim</code></a> and many other functions.</p><div class="admonition is-danger"><header class="admonition-header">Be wary when using `xxxxx_dim`</header><div class="admonition-body"><p>As stated clearly by the documentation strings, all pre-made dimension estimating functions (ending in <code>_dim</code>) perform a lot of automated steps, each having its own heuristic choices for function default values. They are more like convenient bundles with on-average good defaults, rather than precise functions. You should be careful when considering the validity of the returned number!</p></div></div><h2 id="Index-(contents)"><a class="docs-heading-anchor" href="#Index-(contents)">Index (contents)</a><a id="Index-(contents)-1"></a><a class="docs-heading-anchor-permalink" href="#Index-(contents)" title="Permalink"></a></h2><ul><li><a href="#FractalDimensions"><code>FractalDimensions</code></a></li><li><a href="#FractalDimensions.AllSlopesDistribution"><code>FractalDimensions.AllSlopesDistribution</code></a></li><li><a href="#FractalDimensions.BlockMaxima"><code>FractalDimensions.BlockMaxima</code></a></li><li><a href="#FractalDimensions.Exceedances"><code>FractalDimensions.Exceedances</code></a></li><li><a href="#FractalDimensions.LargestLinearRegion"><code>FractalDimensions.LargestLinearRegion</code></a></li><li><a href="#FractalDimensions.LinearRegression"><code>FractalDimensions.LinearRegression</code></a></li><li><a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a></li><li><a href="#FractalDimensions.boxassisted_correlation_dim"><code>FractalDimensions.boxassisted_correlation_dim</code></a></li><li><a href="#FractalDimensions.boxed_correlationsum"><code>FractalDimensions.boxed_correlationsum</code></a></li><li><a href="#FractalDimensions.correlationsum"><code>FractalDimensions.correlationsum</code></a></li><li><a href="#FractalDimensions.estimate_boxsizes"><code>FractalDimensions.estimate_boxsizes</code></a></li><li><a href="#FractalDimensions.estimate_gev_parameters"><code>FractalDimensions.estimate_gev_parameters</code></a></li><li><a href="#FractalDimensions.estimate_gpd_parameters"><code>FractalDimensions.estimate_gpd_parameters</code></a></li><li><a href="#FractalDimensions.estimate_r0_buenoorovio"><code>FractalDimensions.estimate_r0_buenoorovio</code></a></li><li><a href="#FractalDimensions.estimate_r0_theiler"><code>FractalDimensions.estimate_r0_theiler</code></a></li><li><a href="#FractalDimensions.extremal_index_sueveges"><code>FractalDimensions.extremal_index_sueveges</code></a></li><li><a href="#FractalDimensions.extremevaltheory_dim"><code>FractalDimensions.extremevaltheory_dim</code></a></li><li><a href="#FractalDimensions.extremevaltheory_dims"><code>FractalDimensions.extremevaltheory_dims</code></a></li><li><a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>FractalDimensions.extremevaltheory_dims_persistences</code></a></li><li><a href="#FractalDimensions.extremevaltheory_gpdfit_pvalues"><code>FractalDimensions.extremevaltheory_gpdfit_pvalues</code></a></li><li><a href="#FractalDimensions.extremevaltheory_local_dim_persistence"><code>FractalDimensions.extremevaltheory_local_dim_persistence</code></a></li><li><a href="#FractalDimensions.fixedmass_correlation_dim"><code>FractalDimensions.fixedmass_correlation_dim</code></a></li><li><a href="#FractalDimensions.fixedmass_correlationsum"><code>FractalDimensions.fixedmass_correlationsum</code></a></li><li><a href="#FractalDimensions.generalized_dim"><code>FractalDimensions.generalized_dim</code></a></li><li><a href="#FractalDimensions.grassberger_proccacia_dim"><code>FractalDimensions.grassberger_proccacia_dim</code></a></li><li><a href="#FractalDimensions.higuchi_dim"><code>FractalDimensions.higuchi_dim</code></a></li><li><a href="#FractalDimensions.kaplanyorke_dim"><code>FractalDimensions.kaplanyorke_dim</code></a></li><li><a href="#FractalDimensions.linear_region"><code>FractalDimensions.linear_region</code></a></li><li><a href="#FractalDimensions.linear_regions"><code>FractalDimensions.linear_regions</code></a></li><li><a href="#FractalDimensions.linreg"><code>FractalDimensions.linreg</code></a></li><li><a href="#FractalDimensions.local_correlation_dimension"><code>FractalDimensions.local_correlation_dimension</code></a></li><li><a href="#FractalDimensions.minimum_pairwise_distance"><code>FractalDimensions.minimum_pairwise_distance</code></a></li><li><a href="#FractalDimensions.molteno_boxing"><code>FractalDimensions.molteno_boxing</code></a></li><li><a href="#FractalDimensions.molteno_dim"><code>FractalDimensions.molteno_dim</code></a></li><li><a href="#FractalDimensions.pointwise_dimensions"><code>FractalDimensions.pointwise_dimensions</code></a></li><li><a href="#FractalDimensions.prismdim_theiler"><code>FractalDimensions.prismdim_theiler</code></a></li><li><a href="#FractalDimensions.slopefit"><code>FractalDimensions.slopefit</code></a></li><li><a href="#FractalDimensions.takens_best_estimate_dim"><code>FractalDimensions.takens_best_estimate_dim</code></a></li><li><a href="#StateSpaceSets.standardize"><code>StateSpaceSets.standardize</code></a></li></ul><h2 id="Linear-scaling-regions"><a class="docs-heading-anchor" href="#Linear-scaling-regions">Linear scaling regions</a><a id="Linear-scaling-regions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-scaling-regions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.slopefit" href="#FractalDimensions.slopefit"><code>FractalDimensions.slopefit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slopefit(x, y [, t::SLopeFit]; kw...) → s, s05, s95</code></pre><p>Fit a linear scaling region in the curve of the two <code>AbstractVectors</code> <code>y</code> versus <code>x</code> using <code>t</code> as the estimation method. Return the estimated slope, as well as the confidence intervals for it.</p><p>The methods <code>t</code> that can be used for the estimation are:</p><ul><li><a href="#FractalDimensions.LinearRegression"><code>LinearRegression</code></a></li><li><a href="#FractalDimensions.LargestLinearRegion"><code>LargestLinearRegion</code></a> (default)</li><li><a href="#FractalDimensions.AllSlopesDistribution"><code>AllSlopesDistribution</code></a></li></ul><p>The keyword <code>ignore_saturation = true</code> ignores saturation that (sometimes) happens at the start and end of the curve <code>y(x)</code>, where the curve flattens. The keyword <code>sat_threshold = 0.01</code> decides what saturation is: while <code>abs(y[i]-y[i+1]) &lt; sat_threshold</code> we are in a saturation regime. Said differently, slopes with value <code>sat_threshold/dx</code> with <code>dx = x[i+1] - x[i]</code> are neglected.</p><p>The keyword <code>ci = 0.95</code> specifies which quantile (and the 1 - quantile) the confidence interval values are returned at, and by defualt it is 95% (and hence also 5%).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/api.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.LinearRegression" href="#FractalDimensions.LinearRegression"><code>FractalDimensions.LinearRegression</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearRegression &lt;: SlopeFit
LinearRegression()</code></pre><p>Standard linear regression fit to all available data. Estimation of the confidence intervals is based om the standard error of the slope following a T-distribution, see:</p><p>https://stattrek.com/regression/slope-confidence-interval</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/linear_regression.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.linreg" href="#FractalDimensions.linreg"><code>FractalDimensions.linreg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linreg(x, y) -&gt; a, b</code></pre><p>Perform a linear regression to find the best coefficients so that the curve: <code>z = a + b*x</code> has the least squared error with <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/linear_regression.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.LargestLinearRegion" href="#FractalDimensions.LargestLinearRegion"><code>FractalDimensions.LargestLinearRegion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LargestLinearRegion &lt;: SlopeFit
LargestLinearRegion(; dxi::Int = 1, tol = 0.25)</code></pre><p>Identify regions where the curve <code>y(x)</code> is linear, by scanning the <code>x</code>-axis every <code>dxi</code> indices sequentially (e.g. at <code>x[1]</code> to <code>x[5]</code>, <code>x[5]</code> to <code>x[10]</code>, <code>x[10]</code> to <code>x[15]</code> and so on if <code>dxi=5</code>).</p><p>If the slope (calculated via linear regression) of a region of width <code>dxi</code> is approximatelly equal to that of the previous region, within relative tolerance <code>tol</code> and absolute tolerance <code>0</code>, then these two regions belong to the same linear region.</p><p>The largest such region is then used to estimate the slope via standard linear regression of all points belonging to the largest linear region. &quot;Largest&quot; here means the region that covers the more extent along the <code>x</code>-axis.</p><p>Use <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a> if you wish to obtain the decomposition into linear regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/linear_regions.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.linear_regions" href="#FractalDimensions.linear_regions"><code>FractalDimensions.linear_regions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_regions(x, y; dxi, tol) → lrs, tangents</code></pre><p>Apply the algorithm described by <a href="#FractalDimensions.LargestLinearRegion"><code>LargestLinearRegion</code></a>, and return the indices of <code>x</code> that correspond to the linear regions, <code>lrs</code>, and the <code>tangents</code> at each region (obtained via a second linear regression at each accumulated region). <code>lrs</code> is hence a vector of <code>UnitRange</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/linear_regions.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.linear_region" href="#FractalDimensions.linear_region"><code>FractalDimensions.linear_region</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_region(x, y; kwargs...) -&gt; (region, slope)</code></pre><p>Call <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a> and identify and return the largest linear region (a <code>UnitRange</code> of the indices of <code>x</code>) and its corresponding slope.</p><p>The keywords <code>dxi, tol</code> are propagated as-is to <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a>. The keyword <code>ignore_saturation = true</code> ignores saturation that (sometimes) happens at the start and end of the curve <code>y(x)</code>, where the curve flattens. The keyword <code>sat = 0.01</code> decides what saturation is (while <code>abs(y[i]-y[i+1])&lt;sat</code> we are in a saturation regime).</p><p>The keyword <code>warning = true</code> prints a warning if the linear region is less than 1/3 of the available x-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/linear_regions.jl#L106-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.AllSlopesDistribution" href="#FractalDimensions.AllSlopesDistribution"><code>FractalDimensions.AllSlopesDistribution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AllSlopesDistribution &lt;: SlopeFit
AllSlopesDistribution()</code></pre><p>Estimate a slope by computing the distribution of all possible slopes that can be estimated from the curve <code>y(x)</code>, according to the method by (<a href="#Deshmukh2021">Deshmukh <em>et al.</em>, 2021</a>). The returned slope is the distribution mean and the confidence intervals are simply the corresponding quantiles of the distribution.</p><p>Not implemented yet, the method is here as a placeholder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/slopes_distribution.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.estimate_boxsizes" href="#FractalDimensions.estimate_boxsizes"><code>FractalDimensions.estimate_boxsizes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_boxsizes(X::AbstractStateSpaceSet; kwargs...) → εs</code></pre><p>Return <code>k</code> exponentially spaced values: <code>εs = base .^ range(lower + w, upper + z; length = k)</code>, that are a good estimate for sizes ε that are used in calculating a fractal Dimension. It is strongly recommended to <a href="#StateSpaceSets.standardize"><code>standardize</code></a> input dataset before using this function.</p><p>Let <code>d₋</code> be the minimum pair-wise distance in <code>X</code>, <code>d₋ = dminimum_pairwise_distance(X)</code>. Let <code>d₊</code> be the average total length of <code>X</code>, <code>d₊ = mean(ma - mi)</code> with <code>mi, ma = minmaxima(X)</code>. Then <code>lower = log(base, d₋)</code> and <code>upper = log(base, d₊)</code>. Because by default <code>w=1, z=-1</code>, the returned sizes are an order of mangitude larger than the minimum distance, and an order of magnitude smaller than the maximum distance.</p><p><strong>Keywords</strong></p><ul><li><code>w = 1, z = -1, k = 16</code> : as explained above.</li><li><code>base = MathConstants.e</code> : the base used in the <code>log</code> function.</li><li><code>warning = true</code>: Print some warnings for bad estimates.</li><li><code>autoexpand = true</code>: If the final estimated range does not cover at least 2 orders of magnitude, it is automatically expanded by setting <code>w -= we</code> and <code>z -= ze</code>. You can set different default values to the keywords <code>we = w, ze = z</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/estimate_boxsizes.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.minimum_pairwise_distance" href="#FractalDimensions.minimum_pairwise_distance"><code>FractalDimensions.minimum_pairwise_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimum_pairwise_distance(X::StateSpaceSet, kdtree = dimension(X) &lt; 10, metric = Euclidean())</code></pre><p>Return <code>min_d, min_pair</code>: the minimum pairwise distance of all points in the dataset, and the corresponding point pair. The third argument is a switch of whether to use KDTrees or a brute force search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/linear_fits/estimate_boxsizes.jl#L69-L75">source</a></section></article><h2 id="Generalized-(entropy)-dimension"><a class="docs-heading-anchor" href="#Generalized-(entropy)-dimension">Generalized (entropy) dimension</a><a id="Generalized-(entropy)-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-(entropy)-dimension" title="Permalink"></a></h2><p>Based on the definition of the generalized (Renyi) entropy, one can calculate an appropriate dimension, called <em>generalized dimension</em>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.generalized_dim" href="#FractalDimensions.generalized_dim"><code>FractalDimensions.generalized_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generalized_dim(X::StateSpaceSet [, sizes]; q = 1, base = 2) -&gt; Δ_q</code></pre><p>Return the <code>q</code> order generalized dimension of <code>X</code>, by calculating  its histogram-based Rényi entropy for each <code>ε ∈ sizes</code>.</p><p>The case of <code>q = 0</code> is often called &quot;capacity&quot; or &quot;box-counting&quot; dimension, while <code>q = 1</code> is the &quot;information&quot; dimension.</p><p><strong>Description</strong></p><p>The returned dimension is approximated by the (inverse) power law exponent of the scaling of the Renyi entropy <span>$H_q$</span>, versus the box size <code>ε</code>, where <code>ε ∈ sizes</code>:</p><p class="math-container">\[H_q \approx -\Delta_q\log_{b}(\varepsilon)\]</p><p><span>$H_q$</span> is calculated using <code>ComplexityMeasures: Renyi, ValueHistogram, entropy</code>, i.e., by doing a histogram of the data with a given box size.</p><p>Calling this function performs a lot of automated steps:</p><ol><li>A vector of box sizes is decided by calling <code>sizes = estimate_boxsizes(dataset)</code>, if <code>sizes</code> is not given.</li><li>For each element of <code>sizes</code> the appropriate entropy is calculated as<pre><code class="language-julia hljs">H = [entropy(Renyi(; q, base), ValueHistogram(ε), data) for ε ∈ sizes]</code></pre>Let <code>x = -log.(sizes)</code>.</li><li>The curve <code>H(x)</code> is decomposed into linear regions, using <a href="#FractalDimensions.slopefit"><code>slopefit</code></a><code>(x, h)[1]</code>.</li><li>The biggest linear region is chosen, and a fit for the slope of that region is performed using the function <a href="#FractalDimensions.linear_region"><code>linear_region</code></a>, which does a simple linear regression fit using <a href="#FractalDimensions.linreg"><code>linreg</code></a>. This slope is the return value of <code>generalized_dim</code>.</li></ol><p>By doing these steps one by one yourself, you can adjust the keyword arguments given to each of these function calls, refining the accuracy of the result. The source code of this function is only 3 lines of code.</p><p>This approach to estimating the fractal dimension has been used (to our knowledge) for the first time in (<a href="#Russell1980">Russell <em>et al.</em>, 1980</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/entropy_based/generalized_dim.jl#L4-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.molteno_dim" href="#FractalDimensions.molteno_dim"><code>FractalDimensions.molteno_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">molteno_dim(X::AbstractStateSpaceSet; k0::Int = 10, q = 1.0, base = 2)</code></pre><p>Return an estimate of the <a href="#FractalDimensions.generalized_dim"><code>generalized_dim</code></a> of <code>X</code> using the algorithm by (<a href="#Molteno1993">Molteno, 1993</a>). This function is a simple utilization of the probabilities estimated by <a href="#FractalDimensions.molteno_boxing"><code>molteno_boxing</code></a> so see that function for more details. Here the entropy of the probabilities is computed at each size, and a line is fitted in the entropy vs log(size) graph, just like in <a href="#FractalDimensions.generalized_dim"><code>generalized_dim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/entropy_based/molteno.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.molteno_boxing" href="#FractalDimensions.molteno_boxing"><code>FractalDimensions.molteno_boxing</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">molteno_boxing(X::AbstractStateSpaceSet; k0::Int = 10) → (probs, εs)</code></pre><p>Distribute <code>X</code> into boxes whose size is halved in each step, according to the algorithm by (<a href="#Molteno1993">Molteno, 1993</a>). Division stops if the average number of points per filled box falls below the threshold <code>k0</code>.</p><p>Return <code>probs</code>, a vector of <a href="@ref"><code>Probabilities</code></a> of finding points in boxes for different box sizes, and the corresponding box sizes <code>εs</code>. These outputs are used in <a href="#FractalDimensions.molteno_dim"><code>molteno_dim</code></a>.</p><p><strong>Description</strong></p><p>Project the <code>data</code> onto the whole interval of numbers that is covered by <code>UInt64</code>. The projected data is distributed into boxes whose size decreases by factor 2 in each step. For each box that contains more than one point <code>2^D</code> new boxes are created where <code>D</code> is the dimension of the data.</p><p>The process of dividing the data into new boxes stops when the number of points over the number of filled boxes falls below <code>k0</code>. The box sizes <code>εs</code> are calculated and returned together with the <code>probs</code>.</p><p>This algorithm is faster than the traditional approach of using <code>ValueHistogram(ε::Real)</code>, but it is only suited for low dimensional data since it divides each box into <code>2^D</code> new boxes if <code>D</code> is the dimension. For large <code>D</code> this leads to low numbers of box divisions before the threshold is passed and the divison stops. This results to a low number of data points to fit the dimension to and thereby a poor estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/entropy_based/molteno.jl#L18-L45">source</a></section></article><h2 id="Correlation-sum-based-dimension"><a class="docs-heading-anchor" href="#Correlation-sum-based-dimension">Correlation sum based dimension</a><a id="Correlation-sum-based-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-sum-based-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.grassberger_proccacia_dim" href="#FractalDimensions.grassberger_proccacia_dim"><code>FractalDimensions.grassberger_proccacia_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grassberger_proccacia_dim(X::AbstractStateSpaceSet, εs = estimate_boxsizes(data); kwargs...)</code></pre><p>Use the method of Grassberger and Proccacia (<a href="#Grassberger1983">Grassberger and Procaccia, 1983</a>), and the correction by (<a href="#Theiler1986">Theiler, 1986</a>), to estimate the correlation dimension <code>Δ_C</code> of  <code>X</code>.</p><p>This function does something extremely simple:</p><pre><code class="language-julia hljs">cm = correlationsum(data, εs; kwargs...)
Δ_C = slopefit(rs, ys)(log2.(sizes), log2.(cm))[1]</code></pre><p>i.e. it calculates <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> for various radii and then tries to find a linear region in the plot of the log of the correlation sum versus log(ε).</p><p>See <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> for the available keywords. See also <a href="#FractalDimensions.takens_best_estimate_dim"><code>takens_best_estimate_dim</code></a>, <a href="#FractalDimensions.boxassisted_correlation_dim"><code>boxassisted_correlation_dim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_vanilla.jl#L10-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.correlationsum" href="#FractalDimensions.correlationsum"><code>FractalDimensions.correlationsum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correlationsum(X, ε::Real; w = 0, norm = Euclidean(), q = 2) → C_q(ε)</code></pre><p>Calculate the <code>q</code>-order correlation sum of <code>X</code> (<code>StateSpaceSet</code> or timeseries) for a given radius <code>ε</code> and <code>norm</code>. They keyword <code>show_progress = true</code> can be used to display a progress bar for large <code>X</code>.</p><pre><code class="nohighlight hljs">correlationsum(X, εs::AbstractVector; w, norm, q) → C_q(ε)</code></pre><p>If <code>εs</code> is a vector, <code>C_q</code> is calculated for each <code>ε ∈ εs</code> more efficiently. Multithreading is also enabled over the available threads (<code>Threads.nthreads()</code>). The function <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> is typically faster if the dimension of <code>X</code> is small and if <code>maximum(εs)</code> is smaller than the size of <code>X</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>q = 2</code>: order of the correlation sum</li><li><code>norm = Euclidean()</code>: distance norm</li><li><code>w = 0</code>: Theiler window</li><li><code>show_progress = true</code>: display a progress bar</li></ul><p><strong>Description</strong></p><p>The correlation sum is defined as follows for <code>q=2</code>:</p><p class="math-container">\[C_2(\epsilon) = \frac{2}{(N-w)(N-w-1)}\sum_{i=1}^{N}\sum_{j=1+w+i}^{N}
B(||X_i - X_j|| &lt; \epsilon)\]</p><p>for as follows for <code>q≠2</code></p><p class="math-container">\[C_q(\epsilon) = \left[ \sum_{i=1}^{N} \alpha_i
\left[\sum_{j:|i-j| &gt; w} B(||X_i - X_j|| &lt; \epsilon)\right]^{q-1}\right]^{1/(q-1)}\]</p><p>where</p><p class="math-container">\[\alpha_i = 1 / (N (\max(N-w, i) - \min(w + 1, i))^{(q-1)})\]</p><p>with <span>$N$</span> the length of <code>X</code> and <span>$B$</span> gives 1 if its argument is <code>true</code>. <code>w</code> is the <a href="#Theiler-window">Theiler window</a>.</p><p>See the article of Grassberger for the general definition (<a href="#Grassberger2007">Grassberger, 2007</a>) and the book &quot;Nonlinear Time Series Analysis&quot; (<a href="#Kantz2003">Kantz and Schreiber, 2003</a>), Ch. 6, for a discussion around choosing best values for <code>w</code>, and Ch. 11.3 for the explicit definition of the q-order correlationsum. Note that the formula in 11.3 is incorrect, but corrected here, indices are adapted to take advantage of all available points and also note that we immediatelly exponentiate <span>$C_q$</span> to <span>$1/(q-1)$</span>, so that it scales exponentially as <span>$C_q \propto \varepsilon ^\Delta_q$</span> versus the size <span>$\varepsilon$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_vanilla.jl#L33-L81">source</a></section></article><h3 id="Box-assisted-version"><a class="docs-heading-anchor" href="#Box-assisted-version">Box-assisted version</a><a id="Box-assisted-version-1"></a><a class="docs-heading-anchor-permalink" href="#Box-assisted-version" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.boxassisted_correlation_dim" href="#FractalDimensions.boxassisted_correlation_dim"><code>FractalDimensions.boxassisted_correlation_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boxassisted_correlation_dim(X::AbstractStateSpaceSet; kwargs...)</code></pre><p>Use the box-assisted optimizations of (<a href="#BuenoOrovio2007">Bueno-Orovio and Pérez-Garcı́a, 2007</a>) to estimate the correlation dimension <code>Δ_C</code> of <code>X</code>.</p><p>This function does something extremely simple:</p><pre><code class="language-julia hljs">εs, Cs = boxed_correlationsum(X; kwargs...)
slopefit(log2.(εs), log2.(Cs))[1]</code></pre><p>and hence see <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> for more information and available keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_boxassisted.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.boxed_correlationsum" href="#FractalDimensions.boxed_correlationsum"><code>FractalDimensions.boxed_correlationsum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boxed_correlationsum(X::AbstractStateSpaceSet, εs, r0 = maximum(εs); kwargs...) → Cs</code></pre><p>Estimate the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> for each size <code>ε ∈ εs</code> using an optimized algorithm that first distributes data into boxes of size <code>r0</code>, and then computes the correlation sum for each box and each neighboring box of each box. This method is much faster than <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>, <strong>provided that</strong> the box size <code>r0</code> is significantly smaller than the attractor length. Good choices for <code>r0</code> are <a href="#FractalDimensions.estimate_r0_buenoorovio"><code>estimate_r0_buenoorovio</code></a> or <a href="#FractalDimensions.estimate_r0_theiler"><code>estimate_r0_theiler</code></a>.</p><pre><code class="nohighlight hljs">boxed_correlationsum(X::AbstractStateSpaceSet; kwargs...) → εs, Cs</code></pre><p>In this method the minimum inter-point distance and <a href="#FractalDimensions.estimate_r0_buenoorovio"><code>estimate_r0_buenoorovio</code></a> of <code>X</code> are used to estimate suitable <code>εs</code> for the calculation, which are also returned.</p><p><strong>Keyword arguments</strong></p><ul><li><code>q = 2</code> : The order of the correlation sum.</li><li><code>P = 2</code> : The prism dimension.</li><li><code>w = 0</code> : The <a href="#Theiler-window">Theiler window</a>.</li><li><code>show_progress = false</code> : Whether to display a progress bar for the calculation.</li><li><code>norm = Euclidean()</code> : Distance norm.</li></ul><p><strong>Description</strong></p><p><code>C_q(ε)</code> is calculated for every <code>ε ∈ εs</code> and each of the boxes to then be summed up afterwards. The method of splitting the data into boxes was implemented according to (<a href="#Theiler1987">Theiler, 1987</a>). <code>w</code> is the <a href="#Theiler-window">Theiler window</a>. <code>P</code> is the prism dimension. If <code>P</code> is unequal to the dimension of the data, only the first <code>P</code> dimensions are considered for the box distribution (this is called the prism-assisted version). By default <code>P</code> is 2, which is the version suggested by <sup class="footnote-reference"><a id="citeref-Bueno2007" href="#footnote-Bueno2007">[Bueno2007]</a></sup>. Alternative for <code>P</code> is the <a href="#FractalDimensions.prismdim_theiler"><code>prismdim_theiler</code></a>. Note that only when <code>P = dimension(X)</code> the boxed version is guaranteed to be exact to the original <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>. For any other <code>P</code>, some point pairs that should have been included may be skipped due to having smaller distance in the remaining dimensions, but larger distance in the first <code>P</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_boxassisted.jl#L27-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.prismdim_theiler" href="#FractalDimensions.prismdim_theiler"><code>FractalDimensions.prismdim_theiler</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prismdim_theiler(X)</code></pre><p>An algorithm to find the ideal choice of a prism dimension for <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> using Theiler&#39;s original suggestion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_boxassisted.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.estimate_r0_buenoorovio" href="#FractalDimensions.estimate_r0_buenoorovio"><code>FractalDimensions.estimate_r0_buenoorovio</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_r0_buenoorovio(X::AbstractStateSpaceSet, P = 2) → r0, ε0</code></pre><p>Estimate a reasonable size for boxing <code>X</code>, proposed by Bueno-Orovio and Pérez-García (<a href="#BuenoOrovio2007">Bueno-Orovio and Pérez-Garcı́a, 2007</a>), before calculating the correlation dimension as presented by (<a href="#Theiler1987">Theiler, 1987</a>). Return the size <code>r0</code> and the minimum interpoint distance <code>ε0</code> in the data.</p><p>If instead of boxes, prisms are chosen everything stays the same but <code>P</code> is the dimension of the prism. To do so the dimension <code>ν</code> is estimated by running the algorithm by Grassberger and Procaccia (<a href="#Grassberger1983">Grassberger and Procaccia, 1983</a>) with <code>√N</code> points where <code>N</code> is the number of total data points. An effective size <code>ℓ</code> of the attractor is calculated by boxing a small subset of size <code>N/10</code> into boxes of sidelength <code>r_ℓ</code> and counting the number of filled boxes <code>η_ℓ</code>.</p><p class="math-container">\[\ell = r_\ell \eta_\ell ^{1/\nu}\]</p><p>The optimal number of filled boxes <code>η_opt</code> is calculated by minimising the number of calculations.</p><p class="math-container">\[\eta_\textrm{opt} = N^{2/3}\cdot \frac{3^\nu - 1}{3^P - 1}^{1/2}.\]</p><p><code>P</code> is the dimension of the data or the number of edges on the prism that don&#39;t span the whole dataset.</p><p>Then the optimal boxsize <span>$r_0$</span> computes as</p><p class="math-container">\[r_0 = \ell / \eta_\textrm{opt}^{1/\nu}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_boxassisted.jl#L356-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.estimate_r0_theiler" href="#FractalDimensions.estimate_r0_theiler"><code>FractalDimensions.estimate_r0_theiler</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_r0_theiler(X::AbstractStateSpaceSet) → r0, ε0</code></pre><p>Estimate a reasonable size for boxing the data <code>X</code> before calculating the <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> proposed by (<a href="#Theiler1987">Theiler, 1987</a>). Return the boxing size <code>r0</code> and minimum inter-point distance in <code>X</code>, <code>ε0</code>.</p><p>To do so the dimension is estimated by running the algorithm by Grassberger and Procaccia (<a href="#Grassberger1983">Grassberger and Procaccia, 1983</a>) with <code>√N</code> points where <code>N</code> is the number of total data points. Then the optimal boxsize <span>$r_0$</span> computes as</p><p class="math-container">\[r_0 = R (2/N)^{1/\nu}\]</p><p>where <span>$R$</span> is the size of the chaotic attractor and <span>$\nu$</span> is the estimated dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_boxassisted.jl#L315-L328">source</a></section></article><h2 id="Fixed-mass-correlation-sum"><a class="docs-heading-anchor" href="#Fixed-mass-correlation-sum">Fixed mass correlation sum</a><a id="Fixed-mass-correlation-sum-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-mass-correlation-sum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.fixedmass_correlation_dim" href="#FractalDimensions.fixedmass_correlation_dim"><code>FractalDimensions.fixedmass_correlation_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixedmass_correlation_dim(X [, max_j]; kwargs...)</code></pre><p>Use the fixed mass algorithm for computing the correlation sum, and use the result to compute the correlation dimension <code>Δ_M</code> of <code>X</code>.</p><p>This function does something extremely simple:</p><pre><code class="language-julia hljs">rs, ys = fixedmass_correlationsum(X, args...; kwargs...)
slopefit(rs, ys)[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_fixedmass.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.fixedmass_correlationsum" href="#FractalDimensions.fixedmass_correlationsum"><code>FractalDimensions.fixedmass_correlationsum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixedmass_correlationsum(X [, max_j]; metric = Euclidean(), M = length(X)) → rs, ys</code></pre><p>A fixed mass algorithm for the calculation of the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>, and subsequently a fractal dimension <span>$\Delta$</span>, with <code>max_j</code> the maximum number of neighbours that should be considered for the calculation.</p><p>By default <code>max_j = clamp(N*(N-1)/2, 5, 32)</code> with <code>N</code> the data length.</p><p><strong>Keyword arguments</strong></p><ul><li><code>M</code> defines the number of points considered for the averaging of distances, randomly subsampling them from <code>X</code>.</li><li><code>metric = Euclidean()</code> is the distance metric.</li><li><code>start_j = 4</code> computes the equation below starting from <code>j = start_j</code>. Typically the first <code>j</code> values have not converged to the correct scaling of the fractal dimension.</li></ul><p><strong>Description</strong></p><p>&quot;Fixed mass&quot; algorithms mean that instead of trying to find all neighboring points within a radius, one instead tries to find the max radius containing <code>j</code> points. A correlation sum is obtained with this constrain, and equivalently the mean radius containing <code>k</code> points. Based on this, one can calculate <span>$\Delta$</span> approximating the information dimension. The implementation here is due to to (<a href="#Grassberger1988">Grassberger, 1988</a>), which defines</p><p class="math-container">\[Ψ(j) - \log N \sim \Delta \times \overline{\log \left( r_{(j)}\right)}\]</p><p>where <span>$\Psi(j) = \frac{\text{d} \log Γ(j)}{\text{d} j}$</span> is the digamma function, <code>rs</code> = <span>$\overline{\log \left( r_{(j)}\right)}$</span> is the mean logarithm of a radius containing <code>j</code> neighboring points, and <code>ys</code> = <span>$\Psi(j) - \log N$</span> (<span>$N$</span> is the length of the data). The amount of neighbors found <span>$j$</span> range from 2 to <code>max_j</code>. The numbers are also converted to base <span>$2$</span> from base <span>$e$</span>.</p><p><span>$\Delta$</span> can be computed by using <code>linear_region(rs, ys)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_fixedmass.jl#L24-L61">source</a></section></article><h2 id="Takens-best-estimate"><a class="docs-heading-anchor" href="#Takens-best-estimate">Takens best estimate</a><a id="Takens-best-estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Takens-best-estimate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.takens_best_estimate_dim" href="#FractalDimensions.takens_best_estimate_dim"><code>FractalDimensions.takens_best_estimate_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">takens_best_estimate_dim(X, εmax, metric = Chebyshev(), εmin = 0)</code></pre><p>Use the &quot;Takens&#39; best estimate&quot; <sup class="footnote-reference"><a id="citeref-Takens1985" href="#footnote-Takens1985">[Takens1985]</a></sup><sup class="footnote-reference"><a id="citeref-Theiler1988" href="#footnote-Theiler1988">[Theiler1988]</a></sup> method for estimating the correlation dimension.</p><p>The original formula is</p><p class="math-container">\[\Delta_C \approx \frac{C(\epsilon_\text{max})}{\int_0^{\epsilon_\text{max}}(C(\epsilon) / \epsilon) \, d\epsilon}\]</p><p>where <span>$C$</span> is the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> and <span>$\epsilon_\text{max}$</span> is an upper cutoff. Here we use the later expression</p><p class="math-container">\[\Delta_C \approx - \frac{1}{\eta},\quad \eta = \frac{1}{(N-1)^*}\sum_{[i, j]^*}\log(||X_i - X_j|| / \epsilon_\text{max})\]</p><p>where the sum happens for all <span>$i, j$</span> so that <span>$i &lt; j$</span> and <span>$||X_i - X_j|| &lt; \epsilon_\text{max}$</span>. In the above expression, the bias in the original paper has already been corrected, as suggested in <sup class="footnote-reference"><a id="citeref-Borovkova1999" href="#footnote-Borovkova1999">[Borovkova1999]</a></sup>.</p><p>According to <sup class="footnote-reference"><a id="citeref-Borovkova1999" href="#footnote-Borovkova1999">[Borovkova1999]</a></sup>, introducing a lower cutoff <code>εmin</code> can make the algorithm more stable (no divergence), this option is given but defaults to zero.</p><p>If <code>X</code> comes from a delay coordinates embedding of a timseries <code>x</code>, a recommended value for <span>$\epsilon_\text{max}$</span> is <code>std(x)/4</code>.</p><p>You may also use</p><pre><code class="language-julia hljs">Δ_C, Δu_C, Δl_C = FractalDimensions.takens_best_estimate(args...)</code></pre><p>to obtain the upper and lower 95% confidence intervals. The intervals are estimated from the log-likelihood function by finding the values of <code>Δ_C</code> where the function has fallen by 2 from its maximum, see e.g. <sup class="footnote-reference"><a id="citeref-Barlow" href="#footnote-Barlow">[Barlow]</a></sup> chapter 5.3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/takens_best_estimate.jl#L4-L52">source</a></section></article><h2 id="Pointwise-(local)-correlation-dimensions"><a class="docs-heading-anchor" href="#Pointwise-(local)-correlation-dimensions">Pointwise (local) correlation dimensions</a><a id="Pointwise-(local)-correlation-dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Pointwise-(local)-correlation-dimensions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.pointwise_dimensions" href="#FractalDimensions.pointwise_dimensions"><code>FractalDimensions.pointwise_dimensions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_dimensions(X::StateSpaceSet, εs::AbstractVector; kw...) → Δloc</code></pre><p>Return the pointwise dimensions for each point in <code>X</code>, i.e., the exponential scaling of the inner correlation sum</p><p class="math-container">\[c_q(\epsilon) = \left[\sum_{j:|i-j| &gt; w} B(||X_i - X_j|| &lt; \epsilon)\right]^{q-1}\]</p><p>versus <span>$\epsilon$</span>. <code>Δloc[i]</code> is the exponential scaling (deduced by a call to <a href="#FractalDimensions.linear_region"><code>linear_region</code></a>) of <span>$c_q$</span> versus <span>$\epsilon$</span> for the <code>i</code>th point of <code>X</code>.</p><p>Keywords are the same as in <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>. To obtain the inner correlation sums without doing the exponential scaling fit use <code>FractalDimensions.pointwise_correlationsums</code> with same inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_vanilla.jl#L153-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.local_correlation_dimension" href="#FractalDimensions.local_correlation_dimension"><code>FractalDimensions.local_correlation_dimension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_correlation_dimension(X, ζ [, εs]; kw...) → Δ_ζ</code></pre><p>Return the local dimension <code>Δ_ζ</code> around state space point <code>ζ</code> given a set of state space points <code>X</code> which is assumed to surround (or be sufficiently near to) <code>ζ</code>. The local dimension is the exponential scaling of the correlation sum for point <code>ζ</code> versus some radii <code>εs</code>. <code>εs</code> can be a vector of reals, or it can be an integer, in which space that many points are equi-spaced logarithmically between the minimum and maximum distance of <code>X</code> to <code>ζ</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>q = 2, norm = Euclidean()</code>: same as in <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>.</li><li><code>fit = LinearRegression()</code>: given to <a href="#FractalDimensions.slopefit"><code>slopefit</code></a> to estimate the dimension. This default assumes that the set <code>X</code> is already sufficiently close to <code>ζ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/corrsum_based/correlationsum_vanilla.jl#L224-L239">source</a></section></article><h2 id="Kaplan-Yorke-dimension"><a class="docs-heading-anchor" href="#Kaplan-Yorke-dimension">Kaplan-Yorke dimension</a><a id="Kaplan-Yorke-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Kaplan-Yorke-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.kaplanyorke_dim" href="#FractalDimensions.kaplanyorke_dim"><code>FractalDimensions.kaplanyorke_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kaplanyorke_dim(λs::AbstractVector)</code></pre><p>Calculate the Kaplan-Yorke dimension, a.k.a. Lyapunov dimension (<a href="#Kaplan1979">Kaplan and Yorke, 1979</a>) from the given Lyapunov exponents <code>λs</code>.</p><p><strong>Description</strong></p><p>The Kaplan-Yorke dimension is simply the point where <code>cumsum(λs)</code> becomes zero (interpolated):</p><p class="math-container">\[ D_{KY} = k + \frac{\sum_{i=1}^k \lambda_i}{|\lambda_{k+1}|},\quad k = \max_j \left[ \sum_{i=1}^j \lambda_i &gt; 0 \right].\]</p><p>If the sum of the exponents never becomes negative the function will return the length of the input vector.</p><p>Useful in combination with <code>lyapunovspectrum</code> from ChaosTools.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/misc/kaplanyorke.jl#L3-L21">source</a></section></article><h2 id="Higuchi-dimension"><a class="docs-heading-anchor" href="#Higuchi-dimension">Higuchi dimension</a><a id="Higuchi-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Higuchi-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.higuchi_dim" href="#FractalDimensions.higuchi_dim"><code>FractalDimensions.higuchi_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">higuchi_dim(x::AbstractVector [, ks])</code></pre><p>Estimate the Higuchi dimension (<a href="#Higuchi1988">Higuchi, 1988</a>) of the graph of <code>x</code>.</p><p><strong>Description</strong></p><p>The Higuchi dimension is a number <code>Δ ∈ [1, 2]</code> that quantifies the roughness of the graph of the function <code>x(t)</code>, assuming here that <code>x</code> is equi-sampled, like in the original paper.</p><p>The method estimates how the length of the graph increases as a function of the indices difference (which, in this context, is equivalent with differences in <code>t</code>). Specifically, we calculate the average length versus <code>k</code> as</p><p class="math-container">\[L_m(k) = \frac{N-1}{\lfloor \frac{N-m}{k} floor k^2}
\sum_{i=1}^{\lfloor \frac{N-m}{k} \rfloor} |X_N(m+ik)-X_N(m+(i-1)k)| \\

L(k) = \frac{1}{k} \sum_{m=1}^k L_m(k)\]</p><p>and then use <a href="#FractalDimensions.linear_region"><code>linear_region</code></a> in <code>-log2.(k)</code> vs <code>log2.(L)</code> as per usual when computing a fractal dimension.</p><p>The algorithm chooses default <code>ks</code> to be exponentially spaced in base-2, up to at most <code>2^8</code>. A user can provide their own <code>ks</code> as a second argument otherwise.</p><p>Use <code>FractalDimensions.higuchi_length(x, ks)</code> to obtain <span>$L(k)$</span> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/timeseries_roughness/higuchi.jl#L9-L36">source</a></section></article><h2 id="Extreme-value-value-theory-dimensions"><a class="docs-heading-anchor" href="#Extreme-value-value-theory-dimensions">Extreme value value theory dimensions</a><a id="Extreme-value-value-theory-dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Extreme-value-value-theory-dimensions" title="Permalink"></a></h2><p>The central function for this is <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a> which utilizes either <a href="#FractalDimensions.Exceedances"><code>Exceedances</code></a> or <a href="#FractalDimensions.BlockMaxima"><code>BlockMaxima</code></a>.</p><h3 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.extremevaltheory_dims_persistences" href="#FractalDimensions.extremevaltheory_dims_persistences"><code>FractalDimensions.extremevaltheory_dims_persistences</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_dims_persistences(x::AbstractStateSpaceSet, est; kwargs...)</code></pre><p>Return the local dimensions <code>Δloc</code> and the persistences <code>θloc</code> for each point in the given set according to extreme value theory (<a href="#Lucarini2016">Lucarini <em>et al.</em>, 2016</a>). The type of <code>est</code> decides which approach to use when computing the dimension. The possible estimators are:</p><ul><li><a href="#FractalDimensions.BlockMaxima"><code>BlockMaxima</code></a></li><li><a href="#FractalDimensions.Exceedances"><code>Exceedances</code></a></li></ul><p>The computation is parallelized to available threads (<code>Threads.nthreads()</code>).</p><p>See also <a href="#FractalDimensions.extremevaltheory_gpdfit_pvalues"><code>extremevaltheory_gpdfit_pvalues</code></a> for obtaining confidence on the results.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: displays a progress bar.</li><li><code>compute_persistence = true:</code> whether to aso compute local persistences <code>θloc</code> (also called extremal indices). If <code>false</code>, <code>θloc</code> are <code>NaN</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/extremesdim.jl#L15-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.extremevaltheory_dim" href="#FractalDimensions.extremevaltheory_dim"><code>FractalDimensions.extremevaltheory_dim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_dim(X::StateSpaceSet, p; kwargs...) → Δ</code></pre><p>Convenience syntax that returns the mean of the local dimensions of <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a> with <code>X, p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/extremesdim.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.extremevaltheory_dims" href="#FractalDimensions.extremevaltheory_dims"><code>FractalDimensions.extremevaltheory_dims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_dims(X::StateSpaceSet, p; kwargs...) → Δloc</code></pre><p>Convenience syntax that returns the local dimensions of <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a> with <code>X, p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/extremesdim.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.extremevaltheory_local_dim_persistence" href="#FractalDimensions.extremevaltheory_local_dim_persistence"><code>FractalDimensions.extremevaltheory_local_dim_persistence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_local_dim_persistence(X::StateSpaceSet, ζ, p; kw...)</code></pre><p>Return the local values <code>Δ, θ</code> of the fractal dimension and persistence of <code>X</code> around a state space point <code>ζ</code>. <code>p</code> and <code>kw</code> are as in <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/extremesdim.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.extremal_index_sueveges" href="#FractalDimensions.extremal_index_sueveges"><code>FractalDimensions.extremal_index_sueveges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extremal_index_sueveges(y::AbstractVector, p)</code></pre><p>Compute the extremal index θ of <code>y</code> through the Süveges formula for quantile probability <code>p</code>, using the algorithm of (<a href="#Sveges2007">Süveges, 2007</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/extremesdim.jl#L110-L115">source</a></section></article><h3 id="Exceedances-estimator"><a class="docs-heading-anchor" href="#Exceedances-estimator">Exceedances estimator</a><a id="Exceedances-estimator-1"></a><a class="docs-heading-anchor-permalink" href="#Exceedances-estimator" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.Exceedances" href="#FractalDimensions.Exceedances"><code>FractalDimensions.Exceedances</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Exceedances(p::Real, estimator::Symbol)</code></pre><p>Instructions type for <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a> and related functions. This method sets a threshold and fits the exceedances to Generalized Pareto Distribution (GPD). The parameter <code>p</code> is a number between 0 and 1 that determines the p-quantile for the threshold and computation of the extremal index. The argument <code>estimator</code> is a symbol that decides how the GPD is fitted to the data. It can take the values <code>:exp, :pwm, :mm</code>, as in <a href="#FractalDimensions.estimate_gpd_parameters"><code>estimate_gpd_parameters</code></a>.</p><p><strong>Description</strong></p><p>For each state space point <span>$\mathbf{x}_i$</span> in <code>X</code> we compute <span>$g_i = -\log(||\mathbf{x}_i - \mathbf{x}_j|| ) \; \forall j = 1, \ldots, N$</span> with <span>$||\cdot||$</span> the Euclidean distance. Next, we choose an extreme quantile probability <span>$p$</span> (e.g., 0.99) for the distribution of <span>$g_i$</span>. We compute <span>$g_p$</span> as the <span>$p$</span>-th quantile of <span>$g_i$</span>. Then, we collect the exceedances of <span>$g_i$</span>, defined as <span>$E_i = \{ g_i - g_p: g_i \ge g_p \}$</span>, i.e., all values of <span>$g_i$</span> larger or equal to <span>$g_p$</span>, also shifted by <span>$g_p$</span>. There are in total <span>$n = N(1-q)$</span> values in <span>$E_i$</span>. According to extreme value theory, in the limit <span>$N \to \infty$</span> the values <span>$E_i$</span> follow a two-parameter Generalized Pareto Distribution (GPD) with parameters <span>$\sigma,\xi$</span> (the third parameter <span>$\mu$</span> of the GPD is zero due to the positive-definite construction of <span>$E$</span>). Within this extreme value theory approach, the local dimension <span>$\Delta^{(E)}_i$</span> assigned to state space point <span>$\textbf{x}_i$</span> is given by the inverse of the <span>$\sigma$</span> parameter of the GPD fit to the data<sup class="footnote-reference"><a id="citeref-Lucarini2012" href="#footnote-Lucarini2012">[Lucarini2012]</a></sup>, <span>$\Delta^{(E)}_i = 1/\sigma$</span>. <span>$\sigma$</span> is estimated according to the <code>estimator</code> keyword.</p><p>A more precise description of this process is given in the review paper (<a href="#Datseris2023">Datseris <em>et al.</em>, 2023</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/gpd.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.estimate_gpd_parameters" href="#FractalDimensions.estimate_gpd_parameters"><code>FractalDimensions.estimate_gpd_parameters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_gpd_parameters(X::AbstractVector{&lt;:Real}, estimator::Symbol)</code></pre><p>Estimate and return the parameters <code>σ, ξ</code> of a Generalized Pareto Distribution fit to <code>X</code> (which typically is the exceedances of the log distance of a state space set), assuming that <code>minimum(X) ≥ 0</code> and hence the parameter <code>μ</code> is 0 (if not, simply shift <code>X</code> by its minimum), according to the methods provided in (<a href="#Pons2023">Pons <em>et al.</em>, 2023</a>).</p><p>The estimator can be:</p><ul><li><code>:exp</code>: Assume the distribution is exponential instead of GP and get <code>σ</code> from mean of <code>X</code> and set <code>ξ = 0</code>.</li><li><code>mm</code>: Standing for &quot;method of moments&quot;, estimants are given by<p class="math-container">\[\xi = (\bar{x}^2/s^2 - 1)/2, \quad \sigma = \bar{x}(\bar{x}^2/s^2 + 1)/2\]</p>with <span>$\bar{x}$</span> the sample mean and <span>$s^2$</span> the sample variance. This estimator only exists if the true distribution <code>ξ</code> value is &lt; 0.5.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/gpd.jl#L59-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.extremevaltheory_gpdfit_pvalues" href="#FractalDimensions.extremevaltheory_gpdfit_pvalues"><code>FractalDimensions.extremevaltheory_gpdfit_pvalues</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_gpdfit_pvalues(X, p; kw...)</code></pre><p>Return various computed quantities that may quantify the significance of the results of <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a><code>(X, p; kw...)</code>, terms of quantifying how well a Generalized Pareto Distribution (GPD) describes exceedences in the input data.</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: display a progress bar.</li><li><code>TestType = ApproximateOneSampleKSTest</code>: the test type to use. It can be <code>ApproximateOneSampleKSTest, ExactOneSampleKSTest, CramerVonMises</code>. We noticed that <code>OneSampleADTest</code> sometimes yielded nonsensical results: all p-values were equal and were very small ≈ 1e-6.</li><li><code>nbins = round(Int, length(X)*(1-p)/20)</code>: number of bins to use when computing the histogram of the exceedances for computing the NRMSE. The default value will use equally spaced bins that are equal to the length of the exceedances divided by 20.</li></ul><p><strong>Description</strong></p><p>The function computes the exceedances <span>$E_i$</span> for each point <span>$x_i \in X$</span> as in <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a>. It returns 5 quantities, all being vectors of length <code>length(X)</code>:</p><ul><li><code>Es</code>, all exceedences, as a vector of vectors.</li><li><code>sigmas, xis</code> the fitted σ, ξ to the GPD fits for each exceedance</li><li><code>nrmses</code> the normalized root mean square distance of the fitted GPD to the histogram of the exceedances</li><li><code>pvalues</code> the pvalues of a statistical test of the appropriateness of the GPD fit</li></ul><p>The output <code>nrmses</code> quantifies the distance between the fitted GPD and the empirical histogram of the exceedances. It is computed as</p><p class="math-container">\[NRMSE = \sqrt{\frac{\sum{(P_j - G_j)^2}{\sum{(P_j - U)^2}}\]</p><p>where <span>$P_j$</span> the empirical (observed) probability at bin <span>$j$</span>, <span>$G_j$</span> the fitted GPD probability at the midpoint of bin <span>$j$</span>, and <span>$U$</span> same as <span>$G_j$</span> but for the uniform distribution. The divisor of the equation normalizes the expression, so that the error of the empirical distribution is normalized to the error of the empirical distribution with fitting it with the uniform distribution. It is expected that NRMSE &lt; 1. The smaller it is, the better the data are approximated by GPD versus uniform distribution.</p><p>The output <code>pvalues</code> is a vector of p-values. <code>pvalues[i]</code> corresponds to the p-value of the hypothesis: <em>&quot;The exceedences around point <code>X[i]</code> are sampled from a GPD&quot;</em> versus the alternative hypothesis that they are not. To extract the p-values, we perform a one-sample hypothesis via HypothesisTests.jl to the fitted GPD. Very small p-values then indicate that the hypothesis should be rejected and the data are not well described by a GPD. This can be an indication that we do not have enough data, or that we choose too high of a quantile probability <code>p</code>, or that the data are not suitable in general. This p-value based method for significance has been used in <sup class="footnote-reference"><a id="citeref-Faranda2017" href="#footnote-Faranda2017">[Faranda2017]</a></sup>, but it is unclear precisely how it was used.</p><p>For more details on how these quantities may quantify significance, see our review paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/confidence.jl#L9-L70">source</a></section></article><h3 id="Block-maxima-estimator"><a class="docs-heading-anchor" href="#Block-maxima-estimator">Block-maxima estimator</a><a id="Block-maxima-estimator-1"></a><a class="docs-heading-anchor-permalink" href="#Block-maxima-estimator" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.BlockMaxima" href="#FractalDimensions.BlockMaxima"><code>FractalDimensions.BlockMaxima</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockMaxima(blocksize::Int, p::Real)</code></pre><p>Instructions type for <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a> and related functions. This method divides the input data into blocks of length <code>blocksize</code> and fits the maxima of each block to a Generalized Extreme Value distribution. In order for this method to work correctly, both the <code>blocksize</code> and the number of blocks must be high. Note that there are data points that are not used by the algorithm. Since it is not always possible to express the number of input data poins as <code>N = blocksize * nblocks + 1</code>. To reduce the number of unused data, chose an <code>N</code> equal or superior to <code>blocksize * nblocks + 1</code>. This method and several variants of it has been studied in (<a href="#faranda2011numerical">Faranda <em>et al.</em>, 2011</a>)</p><p>The parameter <code>p</code> is a number between 0 and 1 that determines the p-quantile for the computation of the extremal index and hence is irrelevant if <code>compute_persistences = false</code> in <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a>.</p><p>See also <a href="#FractalDimensions.estimate_gev_parameters"><code>estimate_gev_parameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/gev.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FractalDimensions.estimate_gev_parameters" href="#FractalDimensions.estimate_gev_parameters"><code>FractalDimensions.estimate_gev_parameters</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate_gev_parameters(X::AbstractVector{&lt;:Real}, θ::Real)</code></pre><p>Estimate and return the parameters <code>σ, μ</code> of a Generalized Extreme Value distribution fit to <code>X</code> (which typically is the collected block maxima of the log distances of a state space set), assuming that the parameter <code>ξ</code> is 0, and that the extremal index θ is a known constant, and can be estimated through the function <code>extremal_index_sueveges</code>. The estimators through the method of moments are given by     σ = √((̄x²-̄x^2)/(π^2/6))     μ = ̄x - σ(log(θ) + γ) where γ is the constant of Euler-Mascheroni.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/a570bdc8946c14a144002c976d125498d9224ada/src/extremes_based/gev.jl#L61-L73">source</a></section></article><h2 id="Theiler-window"><a class="docs-heading-anchor" href="#Theiler-window">Theiler window</a><a id="Theiler-window-1"></a><a class="docs-heading-anchor-permalink" href="#Theiler-window" title="Permalink"></a></h2><p>The Theiler window is a concept that is useful when finding neighbors in a dataset that is coming from the sampling of a continuous dynamical system. Itt tries to eliminate spurious &quot;correlations&quot; (wrongly counted neighbors) due to a potentially dense sampling of the trajectory. Typically a good choice for <code>w</code> coincides with the choice an optimal delay time, see <code>DelayEmbeddings.estimate_delay</code>, for any of the timeseries of the dataset.</p><p>For more details, see Chapter 5 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p><h2 id="StateSpaceSet-reference"><a class="docs-heading-anchor" href="#StateSpaceSet-reference"><code>StateSpaceSet</code> reference</a><a id="StateSpaceSet-reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.StateSpaceSet" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T, V} &lt;: AbstractVector{V}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>, with element type <code>T</code>, represented by a vector of type <code>V</code>. Typically <code>V</code> is <code>SVector{D,T}</code> or <code>Vector{T}</code> and the data are always stored internally as <code>Vector{V}</code>. <code>SSSet</code> is an alias for <code>StateSpaceSet</code>.</p><p>The underlying <code>Vector{V}</code> can be obtained by <code>vec(ssset)</code>, although this is almost never necessary because <code>StateSpaceSet</code> subtypes <code>AbstractVector</code> and extends its interface. <code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others. When iterated over, it iterates over its contained points.</p><p><strong>Construction</strong></p><p>Constructing a <code>StateSpaceSet</code> is done in three ways:</p><ol><li>By giving in each individual <strong>columns</strong> of the state space set as <code>Vector{&lt;:Real}</code>: <code>StateSpaceSet(x, y, z, ...)</code>.</li><li>By giving in a matrix whose rows are the state space points: <code>StateSpaceSet(m)</code>.</li><li>By giving in directly a vector of vectors (state space points): <code>StateSpaceSet(v_of_v)</code>.</li></ol><p>All constructors allow for the keyword <code>container</code> which sets the type of <code>V</code> (the type of inner vectors). At the moment options are only <code>SVector</code>, <code>MVector</code>, or <code>Vector</code>, and by default <code>SVector</code> is used.</p><p><strong>Description of indexing</strong></p><p>When indexed with 1 index, <code>StateSpaceSet</code> behaves exactly like its encapsulated vector. i.e., a vector of vectors (state space points). When indexed with 2 indices it behaves like a matrix where each row is a point.</p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v2.3.0/src/statespaceset_concrete.jl#L3-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.standardize" href="#StateSpaceSets.standardize"><code>StateSpaceSets.standardize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">standardize(d::StateSpaceSet) → r</code></pre><p>Create a standardized version of the input set where each column is transformed to have mean 0 and standard deviation 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v2.3.0/src/statespaceset_stats.jl#L83-L88">source</a></section><section><div><pre><code class="language-julia hljs">standardize(x::AbstractVector{&lt;:Real}) = (x - mean(x))/std(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v2.3.0/src/timeseries.jl#L17-L19">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><ul><li><div id="BuenoOrovio2007">Bueno-Orovio, A. and Pérez-Garcı́a, V. M. (2007). <a href="https://doi.org/10.1016/j.chaos.2006.03.043"><em>Enhanced box and prism assisted algorithms for computing the correlation dimension</em></a>. <a href="https://doi.org/10.1016/j.chaos.2006.03.043">Chaos,  Solitons &amp;amp<span>$\mathsemicolon$</span> Fractals <strong>34</strong>, 509–518</a>.</div></li><li><div id="Datseris2023">Datseris, G.; Kottlarz, I.; Braun, A. P. and Parlitz, U. (2023). <a href="https://doi.org/10.1063/5.0160394"><em>Estimating fractal dimensions: A comparative review and open source implementations</em></a>. <a href="https://doi.org/10.1063/5.0160394">Chaos: An Interdisciplinary Journal of Nonlinear Science <strong>33</strong></a>.</div></li><li><div id="Deshmukh2021">Deshmukh, V.; Bradley, E.; Garland, J. and Meiss, J. D. (2021). <a href="https://doi.org/10.1063/5.0069365"><em>Toward automated extraction and characterization of scaling regions in dynamical systems</em></a>. <a href="https://doi.org/10.1063/5.0069365">Chaos: An Interdisciplinary Journal of Nonlinear Science <strong>31</strong></a>.</div></li><li><div id="faranda2011numerical">Faranda, D.; Lucarini, V.; Turchetti, G. and Vaienti, S. (2011). <em>Numerical convergence of the block-maxima approach to the generalized extreme value distribution</em>. Journal of statistical physics <strong>145</strong>, 1156–1180.</div></li><li><div id="Grassberger1988">Grassberger, P. (1988). <a href="https://doi.org/10.1016/0375-9601(88)90193-4"><em>Finite sample corrections to entropy and dimension estimates</em></a>. <a href="https://doi.org/10.1016/0375-9601(88)90193-4">Physics Letters A <strong>128</strong>, 369–373</a>.</div></li><li><div id="Grassberger2007">Grassberger, P. (2007). <a href="https://doi.org/10.4249/scholarpedia.3043"><em>Grassberger-Procaccia algorithm</em></a>. <a href="https://doi.org/10.4249/scholarpedia.3043">Scholarpedia <strong>2</strong>, 3043</a>.</div></li><li><div id="Grassberger1983">Grassberger, P. and Procaccia, I. (1983). <a href="https://doi.org/10.1103/physrevlett.50.346"><em>Characterization of Strange Attractors</em></a>. <a href="https://doi.org/10.1103/physrevlett.50.346">Physical Review Letters <strong>50</strong>, 346–349</a>.</div></li><li><div id="Higuchi1988">Higuchi, T. (1988). <a href="https://doi.org/10.1016/0167-2789(88)90081-4"><em>Approach to an irregular time series on the basis of the fractal theory</em></a>. <a href="https://doi.org/10.1016/0167-2789(88)90081-4">Physica D: Nonlinear Phenomena <strong>31</strong>, 277–283</a>.</div></li><li><div id="Kantz2003">Kantz, H. and Schreiber, T. (2003). <a href="https://doi.org/10.1017/cbo9780511755798"><em>Nonlinear Time Series Analysis</em></a> (<a href="https://doi.org/10.1017/cbo9780511755798">Cambridge University Press</a>).</div></li><li><div id="Kaplan1979">Kaplan, J. L. and Yorke, J. A. (1979). <a href="https://doi.org/10.1007/bfb0064319"><em>Chaotic behavior of multidimensional difference equations</em></a>. In: <a href="https://doi.org/10.1007/bfb0064319"><em>Functional Differential Equations and Approximation of Fixed Points</em></a> (Springer Berlin Heidelberg); pp. 204–227.</div></li><li><div id="Lucarini2016">Lucarini, V.; Faranda, D.; Moreira de Freitas, A. C.; de Freitas, J. M.; Holland, M.; Kuna, T.; Nicol, M.; Todd, M. and Vaienti, S. (2016). <em>Extremes and recurrence in dynamical systems</em>. <em>Pure and Applied Mathematics: A Wiley Series of Texts,                Monographs and Tracts</em> (John Wiley &amp; Sons, Nashville, TN).</div></li><li><div id="Molteno1993">Molteno, T. C. (1993). <a href="https://doi.org/10.1103/physreve.48.r3263"><em>Fast<span>$\less$</span>i<span>$\greater$</span>O<span>$\less$</span>/i<span>$\greater$</span>(<span>$\less$</span>i<span>$\greater$</span>N<span>$\less$</span>/i<span>$\greater$</span>) box-counting algorithm for estimating dimensions</em></a>. <a href="https://doi.org/10.1103/physreve.48.r3263">Physical Review E <strong>48</strong>, R3263–R3266</a>.</div></li><li><div id="Pons2023">Pons, F.; Messori, G. and Faranda, D. (2023). <a href="https://doi.org/10.1063/5.0152370"><em>Statistical performance of local attractor dimension estimators in non-Axiom A dynamical systems</em></a>. <a href="https://doi.org/10.1063/5.0152370">Chaos: An Interdisciplinary Journal of Nonlinear Science <strong>33</strong></a>.</div></li><li><div id="Russell1980">Russell, D. A.; Hanson, J. D. and Ott, E. (1980). <a href="https://doi.org/10.1103/physrevlett.45.1175"><em>Dimension of Strange Attractors</em></a>. <a href="https://doi.org/10.1103/physrevlett.45.1175">Physical Review Letters <strong>45</strong>, 1175–1178</a>.</div></li><li><div id="Sveges2007">Süveges, M. (2007). <a href="https://doi.org/10.1007/s10687-007-0034-2"><em>Likelihood estimation of the extremal index</em></a>. <a href="https://doi.org/10.1007/s10687-007-0034-2">Extremes <strong>10</strong>, 41–55</a>.</div></li><li><div id="Theiler1986">Theiler, J. (1986). <a href="https://doi.org/10.1103/physreva.34.2427"><em>Spurious dimension from correlation algorithms applied to limited time-series data</em></a>. <a href="https://doi.org/10.1103/physreva.34.2427">Physical Review A <strong>34</strong>, 2427–2432</a>.</div></li><li><div id="Theiler1987">Theiler, J. (1987). <a href="https://doi.org/10.1103/physreva.36.4456"><em>Efficient algorithm for estimating the correlation dimension from a set of discrete points</em></a>. <a href="https://doi.org/10.1103/physreva.36.4456">Physical Review A <strong>36</strong>, 4456–4462</a>.</div></li></ul></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Takens1985"><a class="tag is-link" href="#citeref-Takens1985">Takens1985</a>Takens, On the numerical determination of the dimension of an attractor, in: B.H.W. Braaksma, B.L.J.F. Takens (Eds.), Dynamical Systems and Bifurcations, in: Lecture Notes in Mathematics, Springer, Berlin, 1985, pp. 99–106.</li><li class="footnote" id="footnote-Theiler1988"><a class="tag is-link" href="#citeref-Theiler1988">Theiler1988</a>Theiler, <a href="https://doi.org/10.1016/0375-9601(88)91016-X">Lacunarity in a best estimator of fractal dimension. Physics Letters A, 133(4–5)</a></li><li class="footnote" id="footnote-Borovkova1999"><a class="tag is-link" href="#citeref-Borovkova1999">Borovkova1999</a>Borovkova et al., <a href="https://doi.org/10.1214/aoap/1029962747">Consistency of the Takens estimator for the correlation dimension. The Annals of Applied Probability, 9, 05 1999.</a></li><li class="footnote" id="footnote-Barlow"><a class="tag is-link" href="#citeref-Barlow">Barlow</a>Barlow, R., Statistics - A Guide to the Use of Statistical Methods in the Physical Sciences. Vol 29. John Wiley &amp; Sons, 1993</li><li class="footnote" id="footnote-Faranda2017"><a class="tag is-link" href="#citeref-Faranda2017">Faranda2017</a>Faranda et al. (2017), Dynamical proxies of North Atlantic predictability and extremes, <a href="https://doi.org/10.1038/srep41278">Scientific Reports, 7</a></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 15 November 2024 16:51">Friday 15 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
