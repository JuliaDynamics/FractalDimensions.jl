var documenterSearchIndex = {"docs":
[{"location":"#FractalDimensions.jl","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"FractalDimensions","category":"page"},{"location":"#FractalDimensions","page":"FractalDimensions.jl","title":"FractalDimensions","text":"FractalDimensions.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that estimates various definitions of fractal dimension from data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"FractalDimensions\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was part of ChaosTools.jl.\n\nCitation\n\nIf you use this package in a publication, please cite the paper below:\n\n@ARTICLE{FractalDimensions.jl,\n  title     = \"Estimating the fractal dimension: a comparative review and open\n               source implementations\",\n  author    = \"Datseris, George and Kottlarz, Inga and Braun, Anton P and\n               Parlitz, Ulrich\",\n  publisher = \"arXiv\",\n  year      =  2021,\n  doi = {10.48550/ARXIV.2109.05937},\n  url = {https://arxiv.org/abs/2109.05937},\n}\n\n\n\n\n\n","category":"module"},{"location":"#Introduction","page":"FractalDimensions.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"note: Note\nThis package is accompanying a review paper on estimating the fractal dimension: https://arxiv.org/abs/2109.05937. The paper is continuing the discussion of chapter 5 of Nonlinear Dynamics, Datseris & Parlitz, Springer 2022.","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"There are numerous methods that one can use to calculate a so-called \"dimension\" of a dataset which in the context of dynamical systems is called the Fractal dimension. One way to do this is to estimate the scaling behaviour of some quantity as a size/scale increases. In the Fractal dimension example below, one finds the scaling of the correlation sum versus a ball radius. In this case, it approximately holds $ \\log(C) \\approx \\Delta\\log(\\varepsilon) $ for radius varepsilon. The scaling of many other quantities can be estimated as well, such as the generalized entropy, the Higuchi length, or others provided here.","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"To actually find Delta, one needs to find a linearly scaling region in the graph log(C) vs. log(varepsilon) and estimate its slope. Hence, identifying a linear region is central to estimating a fractal dimension. That is why, the section Linear scaling regions is of central importance for this documentation.","category":"page"},{"location":"#Fractal-dimension-example","page":"FractalDimensions.jl","title":"Fractal dimension example","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"In this simplest example we will calculate the fractal dimension of the chaotic attractor of the Hénon map (for default parameters). For this example, we will generate the data on the spot:","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"using DynamicalSystemsBase # for simulating dynamical systems\nusing CairoMakie           # for plotting\n\nhenon_rule(x, p, n) = SVector(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])\nu0 = zeros(2)\np0 = [1.4, 0.3]\nhenon = DeterministicIteratedMap(henon_rule, u0, p0)\n\nX, t = trajectory(henon, 20_000; Ttr = 100)\nscatter(X[:, 1], X[:, 2]; color = (\"black\", 0.01), markersize = 4)","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"instead of simulating the set X we could load it from disk, e.g., if there was a text file with two columns as x and y coordinates, we would load it as","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"using DelimitedFiles\nfile = \"path/to/file.csv\"\nM = readdlm(file)    # here `M` is a metrix with two columns\nX = StateSpaceSet(M) # important to convert to a state space set","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"After we have X, we can start computing a fractal dimension and for this example we will use the correlationsum. Our goal is to compute the correlation sum of X for many different sizes/radii ε. This is as simple as","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"using FractalDimensions\nες = 2 .^ (-15:0.5:5) # semi-random guess\nCs = correlationsum(X, ες; show_progress = false)","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"For a fractal set X dynamical systems theory says that there should be an exponential relationship between the correlation sum and the sizes:","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"xs = log2.(ες)\nys = log2.(Cs)\nscatterlines(xs, ys; axis = (ylabel = L\"\\log(C_2)\", xlabel = L\"\\log (\\epsilon)\"))","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"The slope of the linear scaling region of the above plot is the fractal dimension (based on the correlation sum).","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"Given that we see the plot, we can estimate where the linear scaling region starts and ends. However, we can use the function linear_region to get an estimate of the result as well. First let's visualize what it does, as it uses linear_regions.","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"lrs, slopes = linear_regions(xs, ys, tol = 0.25)\nfig = Figure()\nax = Axis(fig[1,1]; ylabel = L\"\\log(C_2)\", xlabel = L\"\\log (\\epsilon)\")\nfor r in lrs\n    scatterlines!(ax, xs[r], ys[r])\nend\nfig","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"The linear_region function finds, and computes the slope of, the largest region:","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"Δ = linear_region(xs, ys)[2]","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"This result is an approximation of a fractal dimension.","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"The whole above pipeline we went through is bundled in grassberger_proccacia_dim. Similar work is done by generalized_dim and many other functions.","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"danger: Be wary when using `xxxxx_dim`\nAs stated clearly by the documentation strings, all pre-made dimension estimating functions (ending in _dim) perform a lot of automated steps, each having its own heuristic choices for function default values. They are more like convenient bundles with on-average good defaults, rather than precise functions. You should be careful when considering the validity of the returned number!","category":"page"},{"location":"#Linear-scaling-regions","page":"FractalDimensions.jl","title":"Linear scaling regions","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"linear_regions\nlinear_region\nlinreg\nestimate_boxsizes\nminimum_pairwise_distance","category":"page"},{"location":"#FractalDimensions.linear_regions","page":"FractalDimensions.jl","title":"FractalDimensions.linear_regions","text":"linear_regions(x, y; dxi::Int = 1, tol = 0.25) -> (lrs, tangents)\n\nIdentify regions where the curve y(x) is linear, by scanning the x-axis every dxi indices sequentially (e.g. at x[1] to x[5], x[5] to x[10], x[10] to x[15] and so on if dxi=5).\n\nIf the slope (calculated via linear regression) of a region of width dxi is approximatelly equal to that of the previous region, within tolerance tol, then these two regions belong to the same linear region.\n\nReturn the indices of x that correspond to the linear regions, lrs, and the correct tangents at each region (obtained via a second linear regression at each accumulated region). lrs is hence a vector of UnitRanges.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.linear_region","page":"FractalDimensions.jl","title":"FractalDimensions.linear_region","text":"linear_region(x, y; kwargs...) -> (region, slope)\n\nCall linear_regions and identify and return the largest linear region (a UnitRange of the indices of x) and its corresponding slope.\n\nThe keywords dxi, tol are propagated as-is to linear_regions. The keyword ignore_saturation = true ignores saturation that (sometimes) happens at the start and end of the curve y(x), where the curve flattens. The keyword sat = 0.01 decides what saturation is (while abs(y[i]-y[i+1])<sat we are in a saturation regime).\n\nThe keyword warning = true prints a warning if the linear region is less than 1/3 of the available x-axis.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.linreg","page":"FractalDimensions.jl","title":"FractalDimensions.linreg","text":"linreg(x, y) -> a, b\n\nPerform a linear regression to find the best coefficients so that the curve: z = a + b*x has the least squared error with y.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.estimate_boxsizes","page":"FractalDimensions.jl","title":"FractalDimensions.estimate_boxsizes","text":"estimate_boxsizes(X::AbstractStateSpaceSet; kwargs...) → εs\n\nReturn k exponentially spaced values: εs = base .^ range(lower + w, upper + z; length = k), that are a good estimate for sizes ε that are used in calculating a Fractal Dimension. It is strongly recommended to standardize input dataset before using this function.\n\nLet d₋ be the minimum pair-wise distance in X, d₋ = dminimum_pairwise_distance(X). Let d₊ be the average total length of X, d₊ = mean(ma - mi) with mi, ma = minmaxima(X). Then lower = log(base, d₋) and upper = log(base, d₊). Because by default w=1, z=-1, the returned sizes are an order of mangitude larger than the minimum distance, and an order of magnitude smaller than the maximum distance.\n\nKeywords\n\nw = 1, z = -1, k = 16 : as explained above.\nbase = MathConstants.e : the base used in the log function.\nwarning = true: Print some warnings for bad estimates.\nautoexpand = true: If the final estimated range does not cover at least 2 orders of magnitude, it is automatically expanded by setting w -= we and z -= ze. You can set different default values to the keywords we = w, ze = z.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.minimum_pairwise_distance","page":"FractalDimensions.jl","title":"FractalDimensions.minimum_pairwise_distance","text":"minimum_pairwise_distance(X::StateSpaceSet, kdtree = dimension(X) < 10, metric = Euclidean())\n\nReturn min_d, min_pair: the minimum pairwise distance of all points in the dataset, and the corresponding point pair. The third argument is a switch of whether to use KDTrees or a brute force search.\n\n\n\n\n\n","category":"function"},{"location":"#Generalized-(entropy)-dimension","page":"FractalDimensions.jl","title":"Generalized (entropy) dimension","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"Based on the definition of the Generalized entropy (genentropy), one can calculate an appropriate dimension, called generalized dimension:","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"generalized_dim\nmolteno_dim\nmolteno_boxing","category":"page"},{"location":"#FractalDimensions.generalized_dim","page":"FractalDimensions.jl","title":"FractalDimensions.generalized_dim","text":"generalized_dim(X::StateSpaceSet [, sizes]; q = 1, base = 2) -> Δ_q\n\nReturn the q order generalized dimension of X, by calculating  its histogram-based Rényi entropy for each ε ∈ sizes.\n\nThe case of q = 0 is often called \"capacity\" or \"box-counting\" dimension, while q = 1 is the \"information\" dimension.\n\nDescription\n\nThe returned dimension is approximated by the (inverse) power law exponent of the scaling of the Renyi entropy H_q, versus the box size ε, where ε ∈ sizes:\n\nH_q approx -Delta_qlog_b(varepsilon)\n\nH_q is calculated using ComplexityMeasures: Renyi, ValueHistogram, entropy, i.e., by doing a histogram of the data with a given box size.\n\nCalling this function performs a lot of automated steps:\n\nA vector of box sizes is decided by calling sizes = estimate_boxsizes(dataset), if sizes is not given.\nFor each element of sizes the appropriate entropy is calculated as\nH = [entropy(Renyi(; q, base), ValueHistogram(ε), data) for ε ∈ sizes]\nLet x = -log.(sizes).\nThe curve H(x) is decomposed into linear regions, using linear_regions(x, h).\nThe biggest linear region is chosen, and a fit for the slope of that region is performed using the function linear_region, which does a simple linear regression fit using linreg. This slope is the return value of generalized_dim.\n\nBy doing these steps one by one yourself, you can adjust the keyword arguments given to each of these function calls, refining the accuracy of the result. The source code of this function is only 3 lines of code.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.molteno_dim","page":"FractalDimensions.jl","title":"FractalDimensions.molteno_dim","text":"molteno_dim(X::AbstractStateSpaceSet; k0::Int = 10, q = 1.0, base = 2)\n\nReturn an estimate of the generalized_dim of X using the algorithm by [Molteno1993]. This function is a simple utilization of the probabilities estimated by molteno_boxing so see that function for more details. Here the entropy of the probabilities is computed at each size, and a line is fitted in the entropy vs log(size) graph, just like in generalized_dim.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.molteno_boxing","page":"FractalDimensions.jl","title":"FractalDimensions.molteno_boxing","text":"molteno_boxing(X::AbstractStateSpaceSet; k0::Int = 10) → (probs, εs)\n\nDistribute X into boxes whose size is halved in each step, according to the algorithm by [Molteno1993]. Division stops if the average number of points per filled box falls below the threshold k0.\n\nReturn probs, a vector of Probabilities of finding points in boxes for different box sizes, and the corresponding box sizes εs. These outputs are used in molteno_dim.\n\nDescription\n\nProject the data onto the whole interval of numbers that is covered by UInt64. The projected data is distributed into boxes whose size decreases by factor 2 in each step. For each box that contains more than one point 2^D new boxes are created where D is the dimension of the data.\n\nThe process of dividing the data into new boxes stops when the number of points over the number of filled boxes falls below k0. The box sizes εs are calculated and returned together with the probs.\n\nThis algorithm is faster than the traditional approach of using ValueHistogram(ε::Real), but it is only suited for low dimensional data since it divides each box into 2^D new boxes if D is the dimension. For large D this leads to low numbers of box divisions before the threshold is passed and the divison stops. This results to a low number of data points to fit the dimension to and thereby a poor estimate.\n\n[Molteno1993]: Molteno, T. C. A., Fast O(N) box-counting algorithm for estimating dimensions. Phys. Rev. E 48, R3263(R) (1993)\n\n\n\n\n\n","category":"function"},{"location":"#Correlation-sum-based-dimension","page":"FractalDimensions.jl","title":"Correlation sum based dimension","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"grassberger_proccacia_dim\ncorrelationsum","category":"page"},{"location":"#FractalDimensions.grassberger_proccacia_dim","page":"FractalDimensions.jl","title":"FractalDimensions.grassberger_proccacia_dim","text":"grassberger_proccacia_dim(X::AbstractStateSpaceSet, εs = estimate_boxsizes(data); kwargs...)\n\nUse the method of Grassberger and Proccacia[Grassberger1983], and the correction by Theiler[Theiler1986], to estimate the correlation dimension Δ_C of  X.\n\nThis function does something extremely simple:\n\ncm = correlationsum(data, εs; kwargs...)\nΔ_C = linear_region(log2.(sizes), log2.(cm))[2]\n\ni.e. it calculates correlationsum for various radii and then tries to find a linear region in the plot of the log of the correlation sum versus log(ε).\n\nSee correlationsum for the available keywords. See also takens_best_estimate, boxassisted_correlation_dim.\n\n[Grassberger1983]: Grassberger and Proccacia, Characterization of strange attractors, PRL 50 (1983) \n\n[Theiler1986]: Theiler, Spurious dimension from correlation algorithms applied to limited time-series data. Physical Review A, 34\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.correlationsum","page":"FractalDimensions.jl","title":"FractalDimensions.correlationsum","text":"correlationsum(X, ε::Real; w = 0, norm = Euclidean(), q = 2) → C_q(ε)\n\nCalculate the q-order correlation sum of X (StateSpaceSet or timeseries) for a given radius ε and norm. They keyword show_progress = true can be used to display a progress bar for large X.\n\ncorrelationsum(X, εs::AbstractVector; w, norm, q) → C_q(ε)\n\nIf εs is a vector, C_q is calculated for each ε ∈ εs more efficiently. Multithreading is also enabled over the available threads (Threads.nthreads()). The function boxed_correlationsum is typically faster if the dimension of X is small and if maximum(εs) is smaller than the size of X.\n\nKeyword arguments\n\nq = 2: order of the correlation sum\nnorm = Euclidean(): distance norm\nw = 0: Theiler window\nshow_progress = true: display a progress bar\n\nDescription\n\nThe correlation sum is defined as follows for q=2:\n\nC_2(epsilon) = frac2(N-w)(N-w-1)sum_i=1^Nsum_j=1+w+i^N\nB(X_i - X_j  epsilon)\n\nfor as follows for q≠2\n\nC_q(epsilon) = leftfrac1alpha sum_i=w+1^N-w\nleftsum_ji-j  w B(X_i - X_j  epsilon)right^q-1right^1(q-1)\n\nwhere\n\nalpha = (N-2w)(N-2w-1)^(q-1)\n\nwith N the length of X and B gives 1 if its argument is true. w is the Theiler window.\n\nSee the article of Grassberger for the general definition [Grassberger2007] and the book \"Nonlinear Time Series Analysis\" [Kantz2003], Ch. 6, for a discussion around choosing best values for w, and Ch. 11.3 for the explicit definition of the q-order correlationsum. Note that the formula in 11.3 is incorrect, but corrected here, and also note that we immediatelly exponentiate C_q to 1(q-1), so that it scales exponentially as C_q propto varepsilon ^Delta_q versus the size varepsilon.\n\n[Grassberger2007]: Peter Grassberger (2007) Grassberger-Procaccia algorithm. Scholarpedia, 2(5):3043.\n\n[Kantz2003]: Kantz, H., & Schreiber, T. (2003). Nonlinear Time Series Analysis, Cambridge University Press.\n\n\n\n\n\n","category":"function"},{"location":"#Box-assisted-version","page":"FractalDimensions.jl","title":"Box-assisted version","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"boxassisted_correlation_dim\nboxed_correlationsum\nprismdim_theiler\nestimate_r0_buenoorovio\nestimate_r0_theiler","category":"page"},{"location":"#FractalDimensions.boxassisted_correlation_dim","page":"FractalDimensions.jl","title":"FractalDimensions.boxassisted_correlation_dim","text":"boxassisted_correlation_dim(X::AbstractStateSpaceSet; kwargs...)\n\nUse the box-assisted optimizations of [Bueno2007] to estimate the correlation dimension Δ_C of X.\n\nThis function does something extremely simple:\n\nεs, Cs = boxed_correlationsum(X; kwargs...)\nreturn linear_region(log2.(Cs), log2.(εs))[2]\n\nand hence see boxed_correlationsum for more information and available keywords.\n\n[Bueno2007]: Bueno-Orovio and Pérez-García, Enhanced box and prism assisted algorithms for computing the correlation dimension. Chaos Solitons & Fractrals, 34(5) \n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.boxed_correlationsum","page":"FractalDimensions.jl","title":"FractalDimensions.boxed_correlationsum","text":"boxed_correlationsum(X::AbstractStateSpaceSet, εs, r0 = maximum(εs); kwargs...) → Cs\n\nEstimate the correlationsum for each size ε ∈ εs using an optimized algorithm that first distributes data into boxes of size r0, and then computes the correlation sum for each box and each neighboring box of each box. This method is much faster than correlationsum, provided that the box size r0 is significantly smaller than the attractor length. Good choices for r0 are estimate_r0_buenoorovio or estimate_r0_theiler.\n\nboxed_correlationsum(X::AbstractStateSpaceSet; kwargs...) → εs, Cs\n\nIn this method the minimum inter-point distance and estimate_r0_buenoorovio of X are used to estimate suitable εs for the calculation, which are also returned.\n\nKeyword arguments\n\nq = 2 : The order of the correlation sum.\nP = 2 : The prism dimension.\nw = 0 : The Theiler window.\nshow_progress = false : Whether to display a progress bar for the calculation.\nnorm = Euclidean() : Distance norm.\n\nDescription\n\nC_q(ε) is calculated for every ε ∈ εs and each of the boxes to then be summed up afterwards. The method of splitting the data into boxes was implemented according to Theiler[Theiler1987]. w is the Theiler window. P is the prism dimension. If P is unequal to the dimension of the data, only the first P dimensions are considered for the box distribution (this is called the prism-assisted version). By default P is 2, which is the version suggested by [Bueno2007]. Alternative for P is the prismdim_theiler. Note that only when P = dimension(X) the boxed version is guaranteed to be exact to the original correlationsum. For any other P, some point pairs that should have been included may be skipped due to having smaller distance in the remaining dimensions, but larger distance in the first P dimensions.\n\n[Theiler1987]: Theiler, Efficient algorithm for estimating the correlation dimension from a set of discrete points. Physical Review A, 36\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.prismdim_theiler","page":"FractalDimensions.jl","title":"FractalDimensions.prismdim_theiler","text":"prismdim_theiler(X)\n\nAn algorithm to find the ideal choice of a prism dimension for boxed_correlationsum using Theiler's original suggestion.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.estimate_r0_buenoorovio","page":"FractalDimensions.jl","title":"FractalDimensions.estimate_r0_buenoorovio","text":"estimate_r0_buenoorovio(X::AbstractStateSpaceSet, P = 2) → r0, ε0\n\nEstimate a reasonable size for boxing X, proposed by Bueno-Orovio and Pérez-García[Bueno2007], before calculating the correlation dimension as presented by Theiler[Theiler1983]. Return the size r0 and the minimum interpoint distance ε0 in the data.\n\nIf instead of boxes, prisms are chosen everything stays the same but P is the dimension of the prism. To do so the dimension ν is estimated by running the algorithm by Grassberger and Procaccia[Grassberger1983] with √N points where N is the number of total data points. An effective size ℓ of the attractor is calculated by boxing a small subset of size N/10 into boxes of sidelength r_ℓ and counting the number of filled boxes η_ℓ.\n\nell = r_ell eta_ell ^1nu\n\nThe optimal number of filled boxes η_opt is calculated by minimising the number of calculations.\n\neta_textrmopt = N^23cdot frac3^nu - 13^P - 1^12\n\nP is the dimension of the data or the number of edges on the prism that don't span the whole dataset.\n\nThen the optimal boxsize r_0 computes as\n\nr_0 = ell  eta_textrmopt^1nu\n\n[Bueno2007]: Bueno-Orovio and Pérez-García, Enhanced box and prism assisted algorithms for computing the correlation dimension. Chaos Solitons & Fractrals, 34(5) \n\n[Theiler1987]: Theiler, Efficient algorithm for estimating the correlation dimension from a set of discrete points. Physical Review A, 36\n\n[Grassberger1983]: Grassberger and Proccacia, Characterization of strange attractors, PRL 50 (1983) \n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.estimate_r0_theiler","page":"FractalDimensions.jl","title":"FractalDimensions.estimate_r0_theiler","text":"estimate_r0_theiler(X::AbstractStateSpaceSet) → r0, ε0\n\nEstimate a reasonable size for boxing the data X before calculating the boxed_correlationsum proposed by Theiler[Theiler1987]. Return the boxing size r0 and minimum inter-point distance in X, ε0.\n\nTo do so the dimension is estimated by running the algorithm by Grassberger and Procaccia[Grassberger1983] with √N points where N is the number of total data points. Then the optimal boxsize r_0 computes as\n\nr_0 = R (2N)^1nu\n\nwhere R is the size of the chaotic attractor and nu is the estimated dimension.\n\n[Theiler1987]: Theiler, Efficient algorithm for estimating the correlation dimension from a set of discrete points. Physical Review A, 36\n\n[Grassberger1983]: Grassberger and Proccacia, Characterization of strange attractors, PRL 50 (1983) \n\n\n\n\n\n","category":"function"},{"location":"#Fixed-mass-correlation-sum","page":"FractalDimensions.jl","title":"Fixed mass correlation sum","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"fixedmass_correlation_dim\nfixedmass_correlationsum","category":"page"},{"location":"#FractalDimensions.fixedmass_correlation_dim","page":"FractalDimensions.jl","title":"FractalDimensions.fixedmass_correlation_dim","text":"fixedmass_correlation_dim(X [, max_j]; kwargs...)\n\nUse the fixed mass algorithm for computing the correlation sum, and use the result to compute the correlation dimension Δ_M of X.\n\nThis function does something extremely simple:\n\nrs, ys = fixedmass_correlationsum(X, args...; kwargs...)\nlinear_region(rs, ys)[2]\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.fixedmass_correlationsum","page":"FractalDimensions.jl","title":"FractalDimensions.fixedmass_correlationsum","text":"fixedmass_correlationsum(X [, max_j]; metric = Euclidean(), M = length(X)) → rs, ys\n\nA fixed mass algorithm for the calculation of the correlationsum, and subsequently a fractal dimension Delta, with max_j the maximum number of neighbours that should be considered for the calculation.\n\nBy default max_j = clamp(N*(N-1)/2, 5, 32) with N the data length.\n\nKeyword arguments\n\nM defines the number of points considered for the averaging of distances, randomly subsampling them from X.\nmetric = Euclidean() is the distance metric.\nstart_j = 4 computes the equation below starting from j = start_j. Typically the first j values have not converged to the correct scaling of the fractal dimension.\n\nDescription\n\n\"Fixed mass\" algorithms mean that instead of trying to find all neighboring points within a radius, one instead tries to find the max radius containing j points. A correlation sum is obtained with this constrain, and equivalently the mean radius containing k points. Based on this, one can calculate Delta approximating the information dimension. The implementation here is due to to [Grassberger1988], which defines\n\nΨ(j) - log N sim Delta times overlinelog left( r_(j)right)\n\nwhere Psi(j) = fractextd log Γ(j)textd j is the digamma function, rs = overlinelog left( r_(j)right) is the mean logarithm of a radius containing j neighboring points, and ys = Psi(j) - log N (N is the length of the data). The amount of neighbors found j range from 2 to max_j. The numbers are also converted to base 2 from base e.\n\nDelta can be computed by using linear_region(rs, ys).\n\n[Grassberger1988]: Peter Grassberger (1988) Finite sample Corrections to Entropy and Dimension Estimates, Physics Letters A 128(6-7)\n\n\n\n\n\n","category":"function"},{"location":"#Takens-best-estimate","page":"FractalDimensions.jl","title":"Takens best estimate","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"takens_best_estimate_dim","category":"page"},{"location":"#FractalDimensions.takens_best_estimate_dim","page":"FractalDimensions.jl","title":"FractalDimensions.takens_best_estimate_dim","text":"takens_best_estimate_dim(X, εmax, metric = Chebyshev(), εmin = 0)\n\nUse the \"Takens' best estimate\" [Takens1985][Theiler1988] method for estimating the correlation dimension.\n\nThe original formula is\n\nDelta_C approx fracC(epsilon_textmax)int_0^epsilon_textmax(C(epsilon)  epsilon)  depsilon\n\nwhere C is the correlationsum and epsilon_textmax is an upper cutoff. Here we use the later expression\n\nDelta_C approx - frac1etaquad eta = frac1(N-1)^*sum_i j^*log(X_i - X_j  epsilon_textmax)\n\nwhere the sum happens for all i j so that i  j and X_i - X_j  epsilon_textmax. In the above expression, the bias in the original paper has already been corrected, as suggested in [Borovkova1999].\n\nAccording to [Borovkova1999], introducing a lower cutoff εmin can make the algorithm more stable (no divergence), this option is given but defaults to zero.\n\nIf X comes from a delay coordinates embedding of a timseries x, a recommended value for epsilon_textmax is std(x)/4.\n\nYou may also use\n\nΔ_C, Δu_C, Δl_C = FractalDimensions.takens_best_estimate(args...)\n\nto obtain the upper and lower 95% confidence intervals. The intervals are estimated from the log-likelihood function by finding the values of Δ_C where the function has fallen by 2 from its maximum, see e.g. [Barlow] chapter 5.3.\n\n[Takens1985]: Takens, On the numerical determination of the dimension of an attractor, in: B.H.W. Braaksma, B.L.J.F. Takens (Eds.), Dynamical Systems and Bifurcations, in: Lecture Notes in Mathematics, Springer, Berlin, 1985, pp. 99–106.\n\n[Theiler1988]: Theiler, Lacunarity in a best estimator of fractal dimension. Physics Letters A, 133(4–5)\n\n[Borovkova1999]: Borovkova et al., Consistency of the Takens estimator for the correlation dimension. The Annals of Applied Probability, 9, 05 1999.\n\n[Barlow]: Barlow, R., Statistics - A Guide to the Use of Statistical Methods in the Physical Sciences. Vol 29. John Wiley & Sons, 1993\n\n\n\n\n\n","category":"function"},{"location":"#Kaplan-Yorke-dimension","page":"FractalDimensions.jl","title":"Kaplan-Yorke dimension","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"kaplanyorke_dim","category":"page"},{"location":"#FractalDimensions.kaplanyorke_dim","page":"FractalDimensions.jl","title":"FractalDimensions.kaplanyorke_dim","text":"kaplanyorke_dim(λs::AbstractVector)\n\nCalculate the Kaplan-Yorke dimension, a.k.a. Lyapunov dimension[Kaplan1970] from the given Lyapunov exponents λs.\n\nDescription\n\nThe Kaplan-Yorke dimension is simply the point where cumsum(λs) becomes zero (interpolated):\n\n D_KY = k + fracsum_i=1^k lambda_ilambda_k+1quad k = max_j left sum_i=1^j lambda_i  0 right\n\nIf the sum of the exponents never becomes negative the function will return the length of the input vector.\n\nUseful in combination with lyapunovspectrum from ChaosTools.jl.\n\n[Kaplan1970]: J. Kaplan & J. Yorke, Chaotic behavior of multidimensional difference equations, Lecture Notes in Mathematics vol. 730, Springer (1979)\n\n\n\n\n\n","category":"function"},{"location":"#Higuchi-dimension","page":"FractalDimensions.jl","title":"Higuchi dimension","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"higuchi_dim","category":"page"},{"location":"#FractalDimensions.higuchi_dim","page":"FractalDimensions.jl","title":"FractalDimensions.higuchi_dim","text":"higuchi_dim(x::AbstractVector [, ks])\n\nEstimate the Higuchi dimension[Higuchi1988] of the graph of x.\n\nDescription\n\nThe Higuchi dimension is a number Δ ∈ [1, 2] that quantifies the roughness of the graph of the function x(t), assuming here that x is equi-sampled, like in the original paper.\n\nThe method estimates how the length of the graph increases as a function of the indices difference (which, in this context, is equivalent with differences in t). Specifically, we calculate the average length versus k as\n\nL_m(k) = fracN-1lfloor fracN-mk \rfloor k^2\nsum_i=1^lfloor fracN-mk rfloor X_N(m+ik)-X_N(m+(i-1)k) \n\nL(k) = frac1k sum_m=1^k L_m(k)\n\nand then use linear_region in -log2.(k) vs log2.(L) as per usual when computing a fractal dimension.\n\nThe algorithm chooses default ks to be exponentially spaced in base-2, up to at most 2^8. A user can provide their own ks as a second argument otherwise.\n\nUse FractalDimensions.higuchi_length(x, ks) to obtain L(k) directly.\n\n[Higuchi1988]: Higuchi, Approach to an irregular time series on the basis of the fractal theory, Physica D: Nonlinear Phenomena (1988)\n\n\n\n\n\n","category":"function"},{"location":"#Extreme-value-value-theory-dimension","page":"FractalDimensions.jl","title":"Extreme value value theory dimension","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"extremevaltheory_dim\nextremevaltheory_dims_persistences\nextremevaltheory_local_dim_persistence\nextremal_index_sueveges\nestimate_gpd_parameters","category":"page"},{"location":"#FractalDimensions.extremevaltheory_dim","page":"FractalDimensions.jl","title":"FractalDimensions.extremevaltheory_dim","text":"extremevaltheory_dim(X::StateSpaceSet, p::Real; kwargs...) → Δ\n\nConvenience syntax that returns the mean of the local dimensions of extremevaltheory_dims_persistences, which approximates a fractal dimension of X using extreme value theory and quantile probability p.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.extremevaltheory_dims_persistences","page":"FractalDimensions.jl","title":"FractalDimensions.extremevaltheory_dims_persistences","text":"extremevaltheory_dims_persistences(x::AbstractStateSpaceSet, p::Real; kwargs)\n\nReturn the local dimensions Δloc and the persistences θloc for each point in the given set for quantile probability p, according to the estimation done via extreme value theory [Lucarini2016] [Caby2018]. The computation is parallelized to available threads (Threads.nthreads()).\n\nKeyword arguments\n\nshow_progress = true: displays a progress bar.\nestimator = :mm: how to estimate the σ parameter of the Generalized Pareto Distribution. The local fractal dimension is 1/σ. The possible values are: :exp, :mm, as in estimate_gpd_parameters.\ncompute_persistence = true: whether to aso compute local persistences θloc (also called extremal index). If false, θloc are NaNs.\nallocate_matrix = false: If true, the code calls a method that attempts to allocate an N×N matrix (N = length(X)) that stores the pairwise Euclidean distances. This method is faster due to optimizations of Distances.pairwise but will error if the computer does not have enough available memory for the matrix allocation.\n\nDescription\n\nFor each state space point mathbfx_i in X we compute g_j = -log(mathbfx_i - mathbfx_j )  forall j = 1 ldots N with cdot the Euclidean distance. Next, we choose an extreme quantile probability p (e.g., 0.99) for the distribution of g_j. We compute g_p as the p-th quantile of g_j. Then, we collect the exceedances of g_j, defined as E =  g_j - g_p g_j ge g_p , i.e., all values of g_j larger or equal to g_p, also shifted by g_p. There are in total n = N(1-q) values in E. According to extreme value theory, in the limit N to infty the values E follow a two-parameter Generalized Pareto Distribution (GPD) with parameters sigmaxi (the third parameter mu of the GPD is zero due to the positive-definite construction of E). Within this extreme value theory approach, the local dimension Delta^(E)_i assigned to state space point textbfx_i is given by the inverse of the sigma parameter of the GPD fit to the data[Faranda2011], Delta^(E)_i = 1sigma. sigma is estimated according to the estimator keyword.\n\n[Lucarini2016]: Lucarini et al., Extremes and Recurrence in Dynamical Systems \n\n[Caby2018]: Caby et al., Physica D 400 132143 \n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.extremevaltheory_local_dim_persistence","page":"FractalDimensions.jl","title":"FractalDimensions.extremevaltheory_local_dim_persistence","text":"extremevaltheory_local_dim_persistence(X::StateSpaceSet, ζ, p::Real; kw...)\n\nReturn the local values Δ, θ of the fractal dimension and persistence of X around a state space point ζ. p and kw are as in extremevaltheory_dims_persistences.\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.extremal_index_sueveges","page":"FractalDimensions.jl","title":"FractalDimensions.extremal_index_sueveges","text":"extremal_index_sueveges(y::AbstractVector, p)\n\nCompute the extremal index θ of y through the Süveges formula for quantile probability p.\n\n[Süveges2007]: Süveges. 2007. Likelihood estimation of the extremal index. Extremes, 10.1-2, 41-55, doi: 10.1007/s10687-007-0034-2\n\n\n\n\n\n","category":"function"},{"location":"#FractalDimensions.estimate_gpd_parameters","page":"FractalDimensions.jl","title":"FractalDimensions.estimate_gpd_parameters","text":"estimate_gpd_parameters(X::AbstractVector{<:Real}, estimator::Symbol = :mm)\n\nEstimate and return the parameters σ, ξ of a Generalized Pareto Distribution fit to X, assuming that minimum(X) == 0 and hence the parameter μ is 0 (if not, simply shift X by its minimum), according to the methods provided in [Flavio2023].\n\nOptionally choose the estimator, which can be:\n\n:exp: Assume the distribution is exponential instead of GP and get σ from mean of X and set ξ = 0.\nmm: Standing for \"method of moments\", estimants are given by\nxi = (barx^2s^2 - 1)2 quad sigma = barx(barx^2s^2 + 1)2\nwith barx the sample mean and s^2 the sample variance. This estimator only exists if the true distribution ξ value is < 0.5.\n\n[Flavio2023]: Flavio et al., Stability of attractor local dimension estimates in non-Axiom A dynamical systems, preprint\n\n\n\n\n\n","category":"function"},{"location":"#Theiler-window","page":"FractalDimensions.jl","title":"Theiler window","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"The Theiler window is a concept that is useful when finding neighbors in a dataset that is coming from the sampling of a continuous dynamical system. Itt tries to eliminate spurious \"correlations\" (wrongly counted neighbors) due to a potentially dense sampling of the trajectory. Typically a good choice for w coincides with the choice an optimal delay time, see DelayEmbeddings.estimate_delay, for any of the timeseries of the dataset.","category":"page"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"For more details, see Chapter 5 of Nonlinear Dynamics, Datseris & Parlitz, Springer 2022.","category":"page"},{"location":"#StateSpaceSet-reference","page":"FractalDimensions.jl","title":"StateSpaceSet reference","text":"","category":"section"},{"location":"","page":"FractalDimensions.jl","title":"FractalDimensions.jl","text":"StateSpaceSet\nstandardize","category":"page"},{"location":"#StateSpaceSets.StateSpaceSet","page":"FractalDimensions.jl","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"#StateSpaceSets.standardize","page":"FractalDimensions.jl","title":"StateSpaceSets.standardize","text":"standardize(d::StateSpaceSet) → r\n\nCreate a standardized version of the input set where each column is transformed to have mean 0 and standard deviation 1.\n\n\n\n\n\nstandardize(x::AbstractVector{<:Real}) = (x - mean(x))/std(x)\n\n\n\n\n\n","category":"function"}]
}
