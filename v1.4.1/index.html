<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FractalDimensions.jl · FractalDimensions.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FractalDimensions.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>FractalDimensions.jl</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Fractal-dimension-example"><span>Fractal dimension example</span></a></li><li><a class="tocitem" href="#Linear-scaling-regions"><span>Linear scaling regions</span></a></li><li><a class="tocitem" href="#Generalized-(entropy)-dimension"><span>Generalized (entropy) dimension</span></a></li><li><a class="tocitem" href="#Correlation-sum-based-dimension"><span>Correlation sum based dimension</span></a></li><li><a class="tocitem" href="#Fixed-mass-correlation-sum"><span>Fixed mass correlation sum</span></a></li><li><a class="tocitem" href="#Takens-best-estimate"><span>Takens best estimate</span></a></li><li><a class="tocitem" href="#Kaplan-Yorke-dimension"><span>Kaplan-Yorke dimension</span></a></li><li><a class="tocitem" href="#Higuchi-dimension"><span>Higuchi dimension</span></a></li><li><a class="tocitem" href="#Extreme-value-value-theory-dimension"><span>Extreme value value theory dimension</span></a></li><li><a class="tocitem" href="#Theiler-window"><span>Theiler window</span></a></li><li><a class="tocitem" href="#StateSpaceSet-reference"><span><code>StateSpaceSet</code> reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FractalDimensions.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FractalDimensions.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FractalDimensions.jl"><a class="docs-heading-anchor" href="#FractalDimensions.jl">FractalDimensions.jl</a><a id="FractalDimensions.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FractalDimensions.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions" href="#FractalDimensions"><code>FractalDimensions</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>FractalDimensions.jl</strong></p><p><a href="https://JuliaDynamics.github.io/FractalDimensions.jl/dev"><img src="https://img.shields.io/badge/docs-dev-lightblue.svg" alt/></a> <a href="https://JuliaDynamics.github.io/FractalDimensions.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://arxiv.org/abs/2109.05937"><img src="https://img.shields.io/badge/DOI-10.48550/ARXIV.2109.05937-purple" alt/></a> <a href="https://github.com/JuliaDynamics/FractalDimensions.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDynamics/FractalDimensions.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/JuliaDynamics/FractalDimensions.jl"><img src="https://codecov.io/gh/JuliaDynamics/FractalDimensions.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://pkgs.genieframework.com?packages=FractalDimensions"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/FractalDimensions" alt="Package Downloads"/></a></p><p>A Julia package that estimates various definitions of fractal dimension from data. It can be used as a standalone package, or as part of <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a>.</p><p>To install it, run <code>import Pkg; Pkg.add(&quot;FractalDimensions&quot;)</code>.</p><p>All further information is provided in the documentation, which you can either find <a href="https://juliadynamics.github.io/FractalDimensions.jl/stable/">online</a> or build locally by running the <code>docs/make.jl</code> file.</p><p><em>Previously, this package was part of ChaosTools.jl.</em></p><p><strong>Citation</strong></p><p>If you use this package in a publication, please cite the paper below:</p><pre><code class="nohighlight hljs">@ARTICLE{FractalDimensions.jl,
  title     = &quot;Estimating the fractal dimension: a comparative review and open
               source implementations&quot;,
  author    = &quot;Datseris, George and Kottlarz, Inga and Braun, Anton P and
               Parlitz, Ulrich&quot;,
  publisher = &quot;arXiv&quot;,
  year      =  2021,
  doi = {10.48550/ARXIV.2109.05937},
  url = {https://arxiv.org/abs/2109.05937},
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/FractalDimensions.jl#L4-L38">source</a></section></article><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package is accompanying a review paper on the fractal dimension: <a href="https://arxiv.org/abs/2109.05937">https://arxiv.org/abs/2109.05937</a>. The paper is continuing the discussion of chapter 5 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p></div></div><p>There are numerous methods that one can use to calculate a so-called &quot;dimension&quot; of a dataset which in the context of dynamical systems is called the <a href="https://en.wikipedia.org/wiki/Fractal_dimension">Fractal dimension</a>. In the majority of cases, computing a fractal dimension means estimating the <strong>scaling behaviour of some quantity as a size/scale increases</strong>. In the <a href="#Fractal-dimension-example">Fractal dimension example</a> below, one finds the scaling of the entropy of the histogram of some data, versus the width of the bins of the histogram. In this case, it approximately holds $ H \approx -\Delta\log(\varepsilon) $ for bin width <span>$\varepsilon$</span>. The scaling of many other quantities can be estimated as well, such as the correlation sum, the Higuchi length, or others provided here.</p><p>To actually find <span>$\Delta$</span>, one needs to find a linearly scaling region in the graph <span>$H$</span> vs. <span>$\log(\varepsilon)$</span> and estimate its slope. Hence, <strong>identifying a linear region is central to estimating a fractal dimension</strong>. That is why, the section <a href="#Linear-scaling-regions">Linear scaling regions</a> is of central importance for this documentation.</p><h2 id="Fractal-dimension-example"><a class="docs-heading-anchor" href="#Fractal-dimension-example">Fractal dimension example</a><a id="Fractal-dimension-example-1"></a><a class="docs-heading-anchor-permalink" href="#Fractal-dimension-example" title="Permalink"></a></h2><p>In this simplest example we will calculate the fractal dimension of the <a href="https://en.wikipedia.org/wiki/H%C3%A9non_map">chaotic attractor of the Hénon map</a> (for default parameters).</p><pre><code class="language- hljs">using DynamicalSystemsBase: DeterministicIteratedMap, trajectory
using CairoMakie

henon_rule(x, p, n) = SVector(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])
u0 = zeros(2)
p0 = [1.4, 0.3]
henon = DeterministicIteratedMap(henon_rule, u0, p0)

X, t = trajectory(henon, 100_000; Ttr = 100)
scatter(X[:, 1], X[:, 2]; color = (&quot;black&quot;, 0.01), markersize = 4)</code></pre><p>Our goal is to compute entropies of the histogram of the above plot for many different partition sizes (bin widths) <code>ε</code>. Computing entropies is the job of <a href="https://github.com/JuliaDynamics/ComplexityMeasures.jl">ComplexityMeasures.jl</a>, but the two relevant names (<code>entropy, ValueHistogram</code>) are re-exported by FractalDimensions.jl.</p><pre><code class="language- hljs">using FractalDimensions
ες = 2 .^ (-15:0.5:5) # semi-random guess
Hs = [entropy(ValueHistogram(ε), X) for ε in ες]</code></pre><pre><code class="language- hljs">xs = @. -log2(ες) # must use same base as `entropy`!!!
scatterlines(xs, Hs; axis = (ylabel = L&quot;H_1&quot;, xlabel = L&quot;-\log (\epsilon)&quot;))</code></pre><p>The slope of the linear scaling region of the above plot is the generalized dimension (of order q = 1) for the attractor of the Hénon map.</p><p>Given that we <em>see</em> the plot, we can estimate where the linear scaling region starts and ends. However, we can use the function <a href="#FractalDimensions.linear_region"><code>linear_region</code></a> to get an estimate of the result as well. First let&#39;s visualize what it does, as it uses <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a>.</p><pre><code class="language- hljs">lrs, slopes = linear_regions(xs, Hs, tol = 0.25)
fig = Figure()
ax = Axis(fig[1,1]; ylabel = L&quot;H_1&quot;, xlabel = L&quot;-\log (\epsilon)&quot;)
for r in lrs
    scatterlines!(ax, xs[r], Hs[r])
end
fig</code></pre><p>The <a href="#FractalDimensions.linear_region"><code>linear_region</code></a> function finds, and computes the slope of, the largest region:</p><pre><code class="language- hljs">Δ = linear_region(xs, Hs)[2]</code></pre><p>This result is an approximation of the information dimension (because we used <code>q = 1</code>) of the attractor.</p><p>The whole above pipeline we went through is bundled in <a href="#FractalDimensions.generalized_dim"><code>generalized_dim</code></a>. Similar pipeline is done by <a href="#FractalDimensions.grassberger_proccacia_dim"><code>grassberger_proccacia_dim</code></a> and many other functions.</p><div class="admonition is-danger"><header class="admonition-header">Be wary when using `xxxxx_dim`</header><div class="admonition-body"><p>As stated clearly by the documentation strings, all pre-made dimension estimating functions (ending in <code>_dim</code>) perform a lot of automated steps, each having its own heuristic choices for function default values. They are more like convenient bundles with on-average good defaults, rather than precise functions. You should be careful when considering the validity of the returned number!</p></div></div><h2 id="Linear-scaling-regions"><a class="docs-heading-anchor" href="#Linear-scaling-regions">Linear scaling regions</a><a id="Linear-scaling-regions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-scaling-regions" title="Permalink"></a></h2><p>And other utilities, especially <a href="#FractalDimensions.linreg"><code>linreg</code></a>, used in both [<code>generalized_dim</code>] and <a href="@ref"><code>grassberger_dim</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.linear_regions" href="#FractalDimensions.linear_regions"><code>FractalDimensions.linear_regions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_regions(x, y; dxi::Int = 1, tol = 0.25) -&gt; (lrs, tangents)</code></pre><p>Identify regions where the curve <code>y(x)</code> is linear, by scanning the <code>x</code>-axis every <code>dxi</code> indices sequentially (e.g. at <code>x[1]</code> to <code>x[5]</code>, <code>x[5]</code> to <code>x[10]</code>, <code>x[10]</code> to <code>x[15]</code> and so on if <code>dxi=5</code>).</p><p>If the slope (calculated via linear regression) of a region of width <code>dxi</code> is approximatelly equal to that of the previous region, within tolerance <code>tol</code>, then these two regions belong to the same linear region.</p><p>Return the indices of <code>x</code> that correspond to the linear regions, <code>lrs</code>, and the correct <code>tangents</code> at each region (obtained via a second linear regression at each accumulated region). <code>lrs</code> is hence a vector of <code>UnitRange</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/linear_regions.jl#L38-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.linear_region" href="#FractalDimensions.linear_region"><code>FractalDimensions.linear_region</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_region(x, y; kwargs...) -&gt; (region, slope)</code></pre><p>Call <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a> and identify and return the largest linear region (a <code>UnitRange</code> of the indices of <code>x</code>) and its corresponding slope.</p><p>The keywords <code>dxi, tol</code> are propagated as-is to <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a>. The keyword <code>ignore_saturation = true</code> ignores saturation that (sometimes) happens at the start and end of the curve <code>y(x)</code>, where the curve flattens. The keyword <code>sat = 0.01</code> decides what saturation is (while <code>abs(y[i]-y[i+1])&lt;sat</code> we are in a saturation regime).</p><p>The keyword <code>warning = true</code> prints a warning if the linear region is less than 1/3 of the available x-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/linear_regions.jl#L100-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.linreg" href="#FractalDimensions.linreg"><code>FractalDimensions.linreg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linreg(x, y) -&gt; a, b</code></pre><p>Perform a linear regression to find the best coefficients so that the curve: <code>z = a + b*x</code> has the least squared error with <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/linear_regions.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.estimate_boxsizes" href="#FractalDimensions.estimate_boxsizes"><code>FractalDimensions.estimate_boxsizes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_boxsizes(X::AbstractStateSpaceSet; kwargs...) → εs</code></pre><p>Return <code>k</code> exponentially spaced values: <code>εs = base .^ range(lower + w, upper + z; length = k)</code>, that are a good estimate for sizes ε that are used in calculating a <a href="@ref">Fractal Dimension</a>. It is strongly recommended to <a href="#StateSpaceSets.standardize"><code>standardize</code></a> input dataset before using this function.</p><p>Let <code>d₋</code> be the minimum pair-wise distance in <code>X</code>, <code>d₋ = dminimum_pairwise_distance(X)</code>. Let <code>d₊</code> be the average total length of <code>X</code>, <code>d₊ = mean(ma - mi)</code> with <code>mi, ma = minmaxima(X)</code>. Then <code>lower = log(base, d₋)</code> and <code>upper = log(base, d₊)</code>. Because by default <code>w=1, z=-1</code>, the returned sizes are an order of mangitude larger than the minimum distance, and an order of magnitude smaller than the maximum distance.</p><p><strong>Keywords</strong></p><ul><li><code>w = 1, z = -1, k = 16</code> : as explained above.</li><li><code>base = MathConstants.e</code> : the base used in the <code>log</code> function.</li><li><code>warning = true</code>: Print some warnings for bad estimates.</li><li><code>autoexpand = true</code>: If the final estimated range does not cover at least 2 orders of magnitude, it is automatically expanded by setting <code>w -= we</code> and <code>z -= ze</code>. You can set different default values to the keywords <code>we = w, ze = z</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/linear_regions.jl#L146-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.minimum_pairwise_distance" href="#FractalDimensions.minimum_pairwise_distance"><code>FractalDimensions.minimum_pairwise_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minimum_pairwise_distance(X::StateSpaceSet, kdtree = dimension(X) &lt; 10, metric = Euclidean())</code></pre><p>Return <code>min_d, min_pair</code>: the minimum pairwise distance of all points in the dataset, and the corresponding point pair. The third argument is a switch of whether to use KDTrees or a brute force search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/linear_regions.jl#L212-L218">source</a></section></article><h2 id="Generalized-(entropy)-dimension"><a class="docs-heading-anchor" href="#Generalized-(entropy)-dimension">Generalized (entropy) dimension</a><a id="Generalized-(entropy)-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-(entropy)-dimension" title="Permalink"></a></h2><p>Based on the definition of the Generalized entropy (<a href="@ref"><code>genentropy</code></a>), one can calculate an appropriate dimension, called <em>generalized dimension</em>:</p><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.generalized_dim" href="#FractalDimensions.generalized_dim"><code>FractalDimensions.generalized_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generalized_dim(X::StateSpaceSet [, sizes]; q = 1, base = 2) -&gt; Δ_q</code></pre><p>Return the <code>q</code> order generalized dimension of <code>X</code>, by calculating  its histogram-based Rényi entropy for each <code>ε ∈ sizes</code>.</p><p>The case of <code>q = 0</code> is often called &quot;capacity&quot; or &quot;box-counting&quot; dimension, while <code>q = 1</code> is the &quot;information&quot; dimension.</p><p><strong>Description</strong></p><p>The returned dimension is approximated by the (inverse) power law exponent of the scaling of the Renyi entropy <span>$H_q$</span>, versus the box size <code>ε</code>, where <code>ε ∈ sizes</code>:</p><p class="math-container">\[H_q \approx -\Delta_q\log_{b}(\varepsilon)\]</p><p><span>$H_q$</span> is calculated using <code>ComplexityMeasures: Renyi, ValueHistogram, entropy</code>, i.e., by doing a histogram of the data with a given box size.</p><p>Calling this function performs a lot of automated steps:</p><ol><li>A vector of box sizes is decided by calling <code>sizes = estimate_boxsizes(dataset)</code>, if <code>sizes</code> is not given.</li><li>For each element of <code>sizes</code> the appropriate entropy is calculated as<pre><code class="language-julia hljs">H = [entropy(Renyi(; q, base), ValueHistogram(ε), data) for ε ∈ sizes]</code></pre>Let <code>x = -log.(sizes)</code>.</li><li>The curve <code>H(x)</code> is decomposed into linear regions, using <a href="#FractalDimensions.linear_regions"><code>linear_regions</code></a><code>(x, h)</code>.</li><li>The biggest linear region is chosen, and a fit for the slope of that region is performed using the function <a href="#FractalDimensions.linear_region"><code>linear_region</code></a>, which does a simple linear regression fit using <a href="#FractalDimensions.linreg"><code>linreg</code></a>. This slope is the return value of <code>generalized_dim</code>.</li></ol><p>By doing these steps one by one yourself, you can adjust the keyword arguments given to each of these function calls, refining the accuracy of the result. The source code of this function is only 3 lines of code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/entropy_based/generalized_dim.jl#L4-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.molteno_dim" href="#FractalDimensions.molteno_dim"><code>FractalDimensions.molteno_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">molteno_dim(X::AbstractStateSpaceSet; k0::Int = 10, q = 1.0, base = 2)</code></pre><p>Return an estimate of the <a href="#FractalDimensions.generalized_dim"><code>generalized_dim</code></a> of <code>X</code> using the algorithm by <sup class="footnote-reference"><a id="citeref-Molteno1993" href="#footnote-Molteno1993">[Molteno1993]</a></sup>. This function is a simple utilization of the probabilities estimated by <a href="#FractalDimensions.molteno_boxing"><code>molteno_boxing</code></a> so see that function for more details. Here the entropy of the probabilities is computed at each size, and a line is fitted in the entropy vs log(size) graph, just like in <a href="#FractalDimensions.generalized_dim"><code>generalized_dim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/entropy_based/molteno.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.molteno_boxing" href="#FractalDimensions.molteno_boxing"><code>FractalDimensions.molteno_boxing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">molteno_boxing(X::AbstractStateSpaceSet; k0::Int = 10) → (probs, εs)</code></pre><p>Distribute <code>X</code> into boxes whose size is halved in each step, according to the algorithm by <sup class="footnote-reference"><a id="citeref-Molteno1993" href="#footnote-Molteno1993">[Molteno1993]</a></sup>. Division stops if the average number of points per filled box falls below the threshold <code>k0</code>.</p><p>Return <code>probs</code>, a vector of <a href="@ref"><code>Probabilities</code></a> of finding points in boxes for different box sizes, and the corresponding box sizes <code>εs</code>. These outputs are used in <a href="#FractalDimensions.molteno_dim"><code>molteno_dim</code></a>.</p><p><strong>Description</strong></p><p>Project the <code>data</code> onto the whole interval of numbers that is covered by <code>UInt64</code>. The projected data is distributed into boxes whose size decreases by factor 2 in each step. For each box that contains more than one point <code>2^D</code> new boxes are created where <code>D</code> is the dimension of the data.</p><p>The process of dividing the data into new boxes stops when the number of points over the number of filled boxes falls below <code>k0</code>. The box sizes <code>εs</code> are calculated and returned together with the <code>probs</code>.</p><p>This algorithm is faster than the traditional approach of using <code>ValueHistogram(ε::Real)</code>, but it is only suited for low dimensional data since it divides each box into <code>2^D</code> new boxes if <code>D</code> is the dimension. For large <code>D</code> this leads to low numbers of box divisions before the threshold is passed and the divison stops. This results to a low number of data points to fit the dimension to and thereby a poor estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/entropy_based/molteno.jl#L18-L49">source</a></section></article><h2 id="Correlation-sum-based-dimension"><a class="docs-heading-anchor" href="#Correlation-sum-based-dimension">Correlation sum based dimension</a><a id="Correlation-sum-based-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-sum-based-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.grassberger_proccacia_dim" href="#FractalDimensions.grassberger_proccacia_dim"><code>FractalDimensions.grassberger_proccacia_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grassberger_proccacia_dim(X::AbstractStateSpaceSet, εs = estimate_boxsizes(data); kwargs...)</code></pre><p>Use the method of Grassberger and Proccacia<sup class="footnote-reference"><a id="citeref-Grassberger1983" href="#footnote-Grassberger1983">[Grassberger1983]</a></sup>, and the correction by Theiler<sup class="footnote-reference"><a id="citeref-Theiler1986" href="#footnote-Theiler1986">[Theiler1986]</a></sup>, to estimate the correlation dimension <code>Δ_C</code> of  <code>X</code>.</p><p>This function does something extremely simple:</p><pre><code class="language-julia hljs">cm = correlationsum(data, εs; kwargs...)
Δ_C = linear_region(log2.(sizes), log2.(cm))[2]</code></pre><p>i.e. it calculates <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> for various radii and then tries to find a linear region in the plot of the log of the correlation sum versus log(ε).</p><p>See <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> for the available keywords. See also <a href="@ref"><code>takens_best_estimate</code></a>, <a href="#FractalDimensions.boxassisted_correlation_dim"><code>boxassisted_correlation_dim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_vanilla.jl#L9-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.correlationsum" href="#FractalDimensions.correlationsum"><code>FractalDimensions.correlationsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">correlationsum(X, ε::Real; w = 0, norm = Euclidean(), q = 2) → C_q(ε)</code></pre><p>Calculate the <code>q</code>-order correlation sum of <code>X</code> (<code>StateSpaceSet</code> or timeseries) for a given radius <code>ε</code> and <code>norm</code>. They keyword <code>show_progress = true</code> can be used to display a progress bar for large <code>X</code>.</p><pre><code class="nohighlight hljs">correlationsum(X, εs::AbstractVector; w, norm, q) → C_q(ε)</code></pre><p>If <code>εs</code> is a vector, <code>C_q</code> is calculated for each <code>ε ∈ εs</code> more efficiently. Multithreading is also enabled over the available threads (<code>Threads.nthreads()</code>). The function <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> is typically faster if the dimension of <code>X</code> is small and if <code>maximum(εs)</code> is smaller than the size of <code>X</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>q = 2</code>: order of the correlation sum</li><li><code>norm = Euclidean()</code>: distance norm</li><li><code>w = 0</code>: Theiler window</li><li><code>show_progress = true</code>: display a progress bar</li></ul><p><strong>Description</strong></p><p>The correlation sum is defined as follows for <code>q=2</code>:</p><p class="math-container">\[C_2(\epsilon) = \frac{2}{(N-w)(N-w-1)}\sum_{i=1}^{N}\sum_{j=1+w+i}^{N}
B(||X_i - X_j|| &lt; \epsilon)\]</p><p>for as follows for <code>q≠2</code></p><p class="math-container">\[C_q(\epsilon) = \left[\frac{1}{\alpha} \sum_{i=w+1}^{N-w}
\left[\sum_{j:|i-j| &gt; w} B(||X_i - X_j|| &lt; \epsilon)\right]^{q-1}\right]^{1/(q-1)}\]</p><p>where</p><p class="math-container">\[\alpha = (N-2w)(N-2w-1)^{(q-1)}\]</p><p>with <span>$N$</span> the length of <code>X</code> and <span>$B$</span> gives 1 if its argument is <code>true</code>. <code>w</code> is the <a href="#Theiler-window">Theiler window</a>.</p><p>See the article of Grassberger for the general definition <sup class="footnote-reference"><a id="citeref-Grassberger2007" href="#footnote-Grassberger2007">[Grassberger2007]</a></sup> and the book &quot;Nonlinear Time Series Analysis&quot; <sup class="footnote-reference"><a id="citeref-Kantz2003" href="#footnote-Kantz2003">[Kantz2003]</a></sup>, Ch. 6, for a discussion around choosing best values for <code>w</code>, and Ch. 11.3 for the explicit definition of the q-order correlationsum. Note that the formula in 11.3 is incorrect, but corrected here, and also note that we immediatelly exponentiate <span>$C_q$</span> to <span>$1/(q-1)$</span>, so that it scales exponentially as <span>$C_q \propto \varepsilon ^\Delta_q$</span> versus the size <span>$\varepsilon$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_vanilla.jl#L39-L93">source</a></section></article><h3 id="Box-assisted-version"><a class="docs-heading-anchor" href="#Box-assisted-version">Box-assisted version</a><a id="Box-assisted-version-1"></a><a class="docs-heading-anchor-permalink" href="#Box-assisted-version" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.boxassisted_correlation_dim" href="#FractalDimensions.boxassisted_correlation_dim"><code>FractalDimensions.boxassisted_correlation_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxassisted_correlation_dim(X::AbstractStateSpaceSet; kwargs...)</code></pre><p>Use the box-assisted optimizations of <sup class="footnote-reference"><a id="citeref-Bueno2007" href="#footnote-Bueno2007">[Bueno2007]</a></sup> to estimate the correlation dimension <code>Δ_C</code> of <code>X</code>.</p><p>This function does something extremely simple:</p><pre><code class="language-julia hljs">εs, Cs = boxed_correlationsum(X; kwargs...)
return linear_region(log2.(Cs), log2.(εs))[2]</code></pre><p>and hence see <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> for more information and available keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_boxassisted.jl#L8-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.boxed_correlationsum" href="#FractalDimensions.boxed_correlationsum"><code>FractalDimensions.boxed_correlationsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxed_correlationsum(X::AbstractStateSpaceSet, εs, r0 = maximum(εs); kwargs...) → Cs</code></pre><p>Estimate the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> for each size <code>ε ∈ εs</code> using an optimized algorithm that first distributes data into boxes of size <code>r0</code>, and then computes the correlation sum for each box and each neighboring box of each box. This method is much faster than <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>, <strong>provided that</strong> the box size <code>r0</code> is significantly smaller than the attractor length. Good choices for <code>r0</code> are <a href="#FractalDimensions.estimate_r0_buenoorovio"><code>estimate_r0_buenoorovio</code></a> or <a href="#FractalDimensions.estimate_r0_theiler"><code>estimate_r0_theiler</code></a>.</p><pre><code class="nohighlight hljs">boxed_correlationsum(X::AbstractStateSpaceSet; kwargs...) → εs, Cs</code></pre><p>In this method the minimum inter-point distance and <a href="#FractalDimensions.estimate_r0_buenoorovio"><code>estimate_r0_buenoorovio</code></a> of <code>X</code> are used to estimate suitable <code>εs</code> for the calculation, which are also returned.</p><p><strong>Keyword arguments</strong></p><ul><li><code>q = 2</code> : The order of the correlation sum.</li><li><code>P = 2</code> : The prism dimension.</li><li><code>w = 0</code> : The <a href="#Theiler-window">Theiler window</a>.</li><li><code>show_progress = false</code> : Whether to display a progress bar for the calculation.</li><li><code>norm = Euclidean()</code> : Distance norm.</li></ul><p><strong>Description</strong></p><p><code>C_q(ε)</code> is calculated for every <code>ε ∈ εs</code> and each of the boxes to then be summed up afterwards. The method of splitting the data into boxes was implemented according to Theiler<sup class="footnote-reference"><a id="citeref-Theiler1987" href="#footnote-Theiler1987">[Theiler1987]</a></sup>. <code>w</code> is the <a href="#Theiler-window">Theiler window</a>. <code>P</code> is the prism dimension. If <code>P</code> is unequal to the dimension of the data, only the first <code>P</code> dimensions are considered for the box distribution (this is called the prism-assisted version). By default <code>P</code> is 2, which is the version suggested by <sup class="footnote-reference"><a id="citeref-Bueno2007" href="#footnote-Bueno2007">[Bueno2007]</a></sup>. Alternative for <code>P</code> is the <a href="#FractalDimensions.prismdim_theiler"><code>prismdim_theiler</code></a>. Note that only when <code>P = dimension(X)</code> the boxed version is guaranteed to be exact to the original <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>. For any other <code>P</code>, some point pairs that should have been included may be skipped due to having smaller distance in the remaining dimensions, but larger distance in the first <code>P</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_boxassisted.jl#L32-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.prismdim_theiler" href="#FractalDimensions.prismdim_theiler"><code>FractalDimensions.prismdim_theiler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prismdim_theiler(X)</code></pre><p>An algorithm to find the ideal choice of a prism dimension for <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> using Theiler&#39;s original suggestion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_boxassisted.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.estimate_r0_buenoorovio" href="#FractalDimensions.estimate_r0_buenoorovio"><code>FractalDimensions.estimate_r0_buenoorovio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_r0_buenoorovio(X::AbstractStateSpaceSet, P = 2) → r0, ε0</code></pre><p>Estimate a reasonable size for boxing <code>X</code>, proposed by Bueno-Orovio and Pérez-García<sup class="footnote-reference"><a id="citeref-Bueno2007" href="#footnote-Bueno2007">[Bueno2007]</a></sup>, before calculating the correlation dimension as presented by Theiler<sup class="footnote-reference"><a id="citeref-Theiler1983" href="#footnote-Theiler1983">[Theiler1983]</a></sup>. Return the size <code>r0</code> and the minimum interpoint distance <code>ε0</code> in the data.</p><p>If instead of boxes, prisms are chosen everything stays the same but <code>P</code> is the dimension of the prism. To do so the dimension <code>ν</code> is estimated by running the algorithm by Grassberger and Procaccia<sup class="footnote-reference"><a id="citeref-Grassberger1983" href="#footnote-Grassberger1983">[Grassberger1983]</a></sup> with <code>√N</code> points where <code>N</code> is the number of total data points. An effective size <code>ℓ</code> of the attractor is calculated by boxing a small subset of size <code>N/10</code> into boxes of sidelength <code>r_ℓ</code> and counting the number of filled boxes <code>η_ℓ</code>.</p><p class="math-container">\[\ell = r_\ell \eta_\ell ^{1/\nu}\]</p><p>The optimal number of filled boxes <code>η_opt</code> is calculated by minimising the number of calculations.</p><p class="math-container">\[\eta_\textrm{opt} = N^{2/3}\cdot \frac{3^\nu - 1}{3^P - 1}^{1/2}.\]</p><p><code>P</code> is the dimension of the data or the number of edges on the prism that don&#39;t span the whole dataset.</p><p>Then the optimal boxsize <span>$r_0$</span> computes as</p><p class="math-container">\[r_0 = \ell / \eta_\textrm{opt}^{1/\nu}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_boxassisted.jl#L378-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.estimate_r0_theiler" href="#FractalDimensions.estimate_r0_theiler"><code>FractalDimensions.estimate_r0_theiler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_r0_theiler(X::AbstractStateSpaceSet) → r0, ε0</code></pre><p>Estimate a reasonable size for boxing the data <code>X</code> before calculating the <a href="#FractalDimensions.boxed_correlationsum"><code>boxed_correlationsum</code></a> proposed by Theiler<sup class="footnote-reference"><a id="citeref-Theiler1987" href="#footnote-Theiler1987">[Theiler1987]</a></sup>. Return the boxing size <code>r0</code> and minimum inter-point distance in <code>X</code>, <code>ε0</code>.</p><p>To do so the dimension is estimated by running the algorithm by Grassberger and Procaccia<sup class="footnote-reference"><a id="citeref-Grassberger1983" href="#footnote-Grassberger1983">[Grassberger1983]</a></sup> with <code>√N</code> points where <code>N</code> is the number of total data points. Then the optimal boxsize <span>$r_0$</span> computes as</p><p class="math-container">\[r_0 = R (2/N)^{1/\nu}\]</p><p>where <span>$R$</span> is the size of the chaotic attractor and <span>$\nu$</span> is the estimated dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_boxassisted.jl#L329-L350">source</a></section></article><h2 id="Fixed-mass-correlation-sum"><a class="docs-heading-anchor" href="#Fixed-mass-correlation-sum">Fixed mass correlation sum</a><a id="Fixed-mass-correlation-sum-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-mass-correlation-sum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.fixedmass_correlation_dim" href="#FractalDimensions.fixedmass_correlation_dim"><code>FractalDimensions.fixedmass_correlation_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fixedmass_correlation_dim(X [, max_j]; kwargs...)</code></pre><p>Use the fixed mass algorithm for computing the correlation sum, and use the result to compute the correlation dimension <code>Δ_M</code> of <code>X</code>.</p><p>This function does something extremely simple:</p><pre><code class="language-julia hljs">rs, ys = fixedmass_correlationsum(X, args...; kwargs...)
linear_region(rs, ys)[2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_fixedmass.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.fixedmass_correlationsum" href="#FractalDimensions.fixedmass_correlationsum"><code>FractalDimensions.fixedmass_correlationsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fixedmass_correlationsum(X [, max_j]; metric = Euclidean(), M = length(X)) → rs, ys</code></pre><p>A fixed mass algorithm for the calculation of the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a>, and subsequently a fractal dimension <span>$\Delta$</span>, with <code>max_j</code> the maximum number of neighbours that should be considered for the calculation.</p><p>By default <code>max_j = clamp(N*(N-1)/2, 5, 32)</code> with <code>N</code> the data length.</p><p><strong>Keyword arguments</strong></p><ul><li><code>M</code> defines the number of points considered for the averaging of distances, randomly subsampling them from <code>X</code>.</li><li><code>metric = Euclidean()</code> is the distance metric.</li><li><code>start_j = 4</code> computes the equation below starting from <code>j = start_j</code>. Typically the first <code>j</code> values have not converged to the correct scaling of the fractal dimension.</li></ul><p><strong>Description</strong></p><p>&quot;Fixed mass&quot; algorithms mean that instead of trying to find all neighboring points within a radius, one instead tries to find the max radius containing <code>j</code> points. A correlation sum is obtained with this constrain, and equivalently the mean radius containing <code>k</code> points. Based on this, one can calculate <span>$\Delta$</span> approximating the information dimension. The implementation here is due to to <sup class="footnote-reference"><a id="citeref-Grassberger1988" href="#footnote-Grassberger1988">[Grassberger1988]</a></sup>, which defines</p><p class="math-container">\[Ψ(j) - \log N \sim \Delta \times \overline{\log \left( r_{(j)}\right)}\]</p><p>where <span>$\Psi(j) = \frac{\text{d} \log Γ(j)}{\text{d} j}$</span> is the digamma function, <code>rs</code> = <span>$\overline{\log \left( r_{(j)}\right)}$</span> is the mean logarithm of a radius containing <code>j</code> neighboring points, and <code>ys</code> = <span>$\Psi(j) - \log N$</span> (<span>$N$</span> is the length of the data). The amount of neighbors found <span>$j$</span> range from 2 to <code>max_j</code>. The numbers are also converted to base <span>$2$</span> from base <span>$e$</span>.</p><p><span>$\Delta$</span> can be computed by using <code>linear_region(rs, ys)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/correlationsum_fixedmass.jl#L24-L65">source</a></section></article><h2 id="Takens-best-estimate"><a class="docs-heading-anchor" href="#Takens-best-estimate">Takens best estimate</a><a id="Takens-best-estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Takens-best-estimate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.takens_best_estimate_dim" href="#FractalDimensions.takens_best_estimate_dim"><code>FractalDimensions.takens_best_estimate_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">takens_best_estimate_dim(X, εmax, metric = Chebyshev(), εmin = 0)</code></pre><p>Use the &quot;Takens&#39; best estimate&quot; <sup class="footnote-reference"><a id="citeref-Takens1985" href="#footnote-Takens1985">[Takens1985]</a></sup><sup class="footnote-reference"><a id="citeref-Theiler1988" href="#footnote-Theiler1988">[Theiler1988]</a></sup> method for estimating the correlation dimension.</p><p>The original formula is</p><p class="math-container">\[\Delta_C \approx \frac{C(\epsilon_\text{max})}{\int_0^{\epsilon_\text{max}}(C(\epsilon) / \epsilon) \, d\epsilon}\]</p><p>where <span>$C$</span> is the <a href="#FractalDimensions.correlationsum"><code>correlationsum</code></a> and <span>$\epsilon_\text{max}$</span> is an upper cutoff. Here we use the later expression</p><p class="math-container">\[\Delta_C \approx - \frac{1}{\eta},\quad \eta = \frac{1}{(N-1)^*}\sum_{[i, j]^*}\log(||X_i - X_j|| / \epsilon_\text{max})\]</p><p>where the sum happens for all <span>$i, j$</span> so that <span>$i &lt; j$</span> and <span>$||X_i - X_j|| &lt; \epsilon_\text{max}$</span>. In the above expression, the bias in the original paper has already been corrected, as suggested in <sup class="footnote-reference"><a id="citeref-Borovkova1999" href="#footnote-Borovkova1999">[Borovkova1999]</a></sup>.</p><p>According to <sup class="footnote-reference"><a id="citeref-Borovkova1999" href="#footnote-Borovkova1999">[Borovkova1999]</a></sup>, introducing a lower cutoff <code>εmin</code> can make the algorithm more stable (no divergence), this option is given but defaults to zero.</p><p>If <code>X</code> comes from a delay coordinates embedding of a timseries <code>x</code>, a recommended value for <span>$\epsilon_\text{max}$</span> is <code>std(x)/4</code>.</p><p>You may also use</p><pre><code class="language-julia hljs">Δ_C, Δu_C, Δl_C = FractalDimensions.takens_best_estimate(args...)</code></pre><p>to obtain the upper and lower 95% confidence intervals. The intervals are estimated from the log-likelihood function by finding the values of <code>Δ_C</code> where the function has fallen by 2 from its maximum, see e.g. <sup class="footnote-reference"><a id="citeref-Barlow" href="#footnote-Barlow">[Barlow]</a></sup> chapter 5.3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/corrsum_based/takens_best_estimate.jl#L4-L52">source</a></section></article><h2 id="Kaplan-Yorke-dimension"><a class="docs-heading-anchor" href="#Kaplan-Yorke-dimension">Kaplan-Yorke dimension</a><a id="Kaplan-Yorke-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Kaplan-Yorke-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.kaplanyorke_dim" href="#FractalDimensions.kaplanyorke_dim"><code>FractalDimensions.kaplanyorke_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kaplanyorke_dim(λs::AbstractVector)</code></pre><p>Calculate the Kaplan-Yorke dimension, a.k.a. Lyapunov dimension<sup class="footnote-reference"><a id="citeref-Kaplan1970" href="#footnote-Kaplan1970">[Kaplan1970]</a></sup> from the given Lyapunov exponents <code>λs</code>.</p><p><strong>Description</strong></p><p>The Kaplan-Yorke dimension is simply the point where <code>cumsum(λs)</code> becomes zero (interpolated):</p><p class="math-container">\[ D_{KY} = k + \frac{\sum_{i=1}^k \lambda_i}{|\lambda_{k+1}|},\quad k = \max_j \left[ \sum_{i=1}^j \lambda_i &gt; 0 \right].\]</p><p>If the sum of the exponents never becomes negative the function will return the length of the input vector.</p><p>Useful in combination with <code>lyapunovspectrum</code> from ChaosTools.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/misc/kaplanyorke.jl#L3-L24">source</a></section></article><h2 id="Higuchi-dimension"><a class="docs-heading-anchor" href="#Higuchi-dimension">Higuchi dimension</a><a id="Higuchi-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Higuchi-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.higuchi_dim" href="#FractalDimensions.higuchi_dim"><code>FractalDimensions.higuchi_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">higuchi_dim(x::AbstractVector [, ks])</code></pre><p>Estimate the Higuchi dimension<sup class="footnote-reference"><a id="citeref-Higuchi1988" href="#footnote-Higuchi1988">[Higuchi1988]</a></sup> of the graph of <code>x</code>.</p><p><strong>Description</strong></p><p>The Higuchi dimension is a number <code>Δ ∈ [1, 2]</code> that quantifies the roughness of the graph of the function <code>x(t)</code>, assuming here that <code>x</code> is equi-sampled, like in the original paper.</p><p>The method estimates how the length of the graph increases as a function of the indices difference (which, in this context, is equivalent with differences in <code>t</code>). Specifically, we calculate the average length versus <code>k</code> as</p><p class="math-container">\[L_m(k) = \frac{N-1}{\lfloor \frac{N-m}{k} floor k^2}
\sum_{i=1}^{\lfloor \frac{N-m}{k} \rfloor} |X_N(m+ik)-X_N(m+(i-1)k)| \\

L(k) = \frac{1}{k} \sum_{m=1}^k L_m(k)\]</p><p>and then use <a href="#FractalDimensions.linear_region"><code>linear_region</code></a> in <code>-log2.(k)</code> vs <code>log2.(L)</code> as per usual when computing a fractal dimension.</p><p>The algorithm chooses default <code>ks</code> to be exponentially spaced in base-2, up to at most <code>2^8</code>. A user can provide their own <code>ks</code> as a second argument otherwise.</p><p>Use <code>FractalDimensions.higuchi_length(x, ks)</code> to obtain <span>$L(k)$</span> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/timeseries_roughness/higuchi.jl#L9-L40">source</a></section></article><h2 id="Extreme-value-value-theory-dimension"><a class="docs-heading-anchor" href="#Extreme-value-value-theory-dimension">Extreme value value theory dimension</a><a id="Extreme-value-value-theory-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Extreme-value-value-theory-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.extremevaltheory_dim" href="#FractalDimensions.extremevaltheory_dim"><code>FractalDimensions.extremevaltheory_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_dim(X::StateSpaceSet, p::Real; kwargs...) → Δ</code></pre><p>Convenience syntax that returns the mean of the local dimensions of <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a>, which approximates a fractal dimension of <code>X</code> using extreme value theory and quantile probability <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/extremes_based/extremesdim.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.extremevaltheory_dims_persistences" href="#FractalDimensions.extremevaltheory_dims_persistences"><code>FractalDimensions.extremevaltheory_dims_persistences</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_dims_persistences(x::AbstractStateSpaceSet, p::Real; kwargs)</code></pre><p>Return the local dimensions <code>Δloc</code> and the persistences <code>θloc</code> for each point in the given set for quantile probability <code>p</code>, according to the estimation done via extreme value theory <sup class="footnote-reference"><a id="citeref-Lucarini2016" href="#footnote-Lucarini2016">[Lucarini2016]</a></sup> <sup class="footnote-reference"><a id="citeref-Caby2018" href="#footnote-Caby2018">[Caby2018]</a></sup>. The computation is parallelized to available threads (<code>Threads.nthreads()</code>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>show_progress = true</code>: displays a progress bar.</li><li><code>estimator = :mm</code>: how to estimate the <code>σ</code> parameter of the Generalized Pareto Distribution. The local fractal dimension is <code>1/σ</code>. The possible values are: <code>:exp, :mm</code>, as in <a href="#FractalDimensions.estimate_gpd_parameters"><code>estimate_gpd_parameters</code></a>.</li><li><code>compute_persistence = true:</code> whether to aso compute local persistences <code>θloc</code> (also called extremal index). If <code>false</code>, <code>θloc</code> are <code>NaN</code>s.</li><li><code>allocate_matrix = false</code>: If <code>true</code>, the code calls a method that attempts to allocate an <code>N×N</code> matrix (<code>N = length(X)</code>) that stores the pairwise Euclidean distances. This method is faster due to optimizations of <code>Distances.pairwise</code> but will error if the computer does not have enough available memory for the matrix allocation.</li></ul><p><strong>Description</strong></p><p>For each state space point <span>$\mathbf{x}_i$</span> in <code>X</code> we compute <span>$g_j = -\log(||\mathbf{x}_i - \mathbf{x}_j|| ) \; \forall j = 1, \ldots, N$</span> with <span>$||\cdot||$</span> the Euclidean distance. Next, we choose an extreme quantile probability <span>$p$</span> (e.g., 0.99) for the distribution of <span>$g_j$</span>. We compute <span>$g_p$</span> as the <span>$p$</span>-th quantile of <span>$g_j$</span>. Then, we collect the exceedances of <span>$g_j$</span>, defined as <span>$E = \{ g_j - g_p: g_j \ge g_p \}$</span>, i.e., all values of <span>$g_j$</span> larger or equal to <span>$g_p$</span>, also shifted by <span>$g_p$</span>. There are in total <span>$n = N(1-q)$</span> values in <span>$E$</span>. According to extreme value theory, in the limit <span>$N \to \infty$</span> the values <span>$E$</span> follow a two-parameter Generalized Pareto Distribution (GPD) with parameters <span>$\sigma,\xi$</span> (the third parameter <span>$\mu$</span> of the GPD is zero due to the positive-definite construction of <span>$E$</span>). Within this extreme value theory approach, the local dimension <span>$\Delta^{(E)}_i$</span> assigned to state space point <span>$\textbf{x}_i$</span> is given by the inverse of the <span>$\sigma$</span> parameter of the GPD fit to the data<sup class="footnote-reference"><a id="citeref-Faranda2011" href="#footnote-Faranda2011">[Faranda2011]</a></sup>, <span>$\Delta^{(E)}_i = 1/\sigma$</span>. <span>$\sigma$</span> is estimated according to the <code>estimator</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/extremes_based/extremesdim.jl#L33-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.extremevaltheory_local_dim_persistence" href="#FractalDimensions.extremevaltheory_local_dim_persistence"><code>FractalDimensions.extremevaltheory_local_dim_persistence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extremevaltheory_local_dim_persistence(X::StateSpaceSet, ζ, p::Real; kw...)</code></pre><p>Return the local values <code>Δ, θ</code> of the fractal dimension and persistence of <code>X</code> around a state space point <code>ζ</code>. <code>p</code> and <code>kw</code> are as in <a href="#FractalDimensions.extremevaltheory_dims_persistences"><code>extremevaltheory_dims_persistences</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/extremes_based/extremesdim.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.extremal_index_sueveges" href="#FractalDimensions.extremal_index_sueveges"><code>FractalDimensions.extremal_index_sueveges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extremal_index_sueveges(y::AbstractVector, p)</code></pre><p>Compute the extremal index θ of <code>y</code> through the Süveges formula for quantile probability <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/extremes_based/extremesdim.jl#L200-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FractalDimensions.estimate_gpd_parameters" href="#FractalDimensions.estimate_gpd_parameters"><code>FractalDimensions.estimate_gpd_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_gpd_parameters(X::AbstractVector{&lt;:Real}, estimator::Symbol = :mm)</code></pre><p>Estimate and return the parameters <code>σ, ξ</code> of a Generalized Pareto Distribution fit to <code>X</code>, assuming that <code>minimum(X) == 0</code> and hence the parameter <code>μ</code> is 0 (if not, simply shift <code>X</code> by its minimum), according to the methods provided in <sup class="footnote-reference"><a id="citeref-Flavio2023" href="#footnote-Flavio2023">[Flavio2023]</a></sup>.</p><p>Optionally choose the estimator, which can be:</p><ul><li><code>:exp</code>: Assume the distribution is exponential instead of GP and get <code>σ</code> from mean of <code>X</code> and set <code>ξ = 0</code>.</li><li><code>mm</code>: Standing for &quot;method of moments&quot;, estimants are given by<p class="math-container">\[\xi = (\bar{x}^2/s^2 - 1)/2, \quad \sigma = \bar{x}(\bar{x}^2/s^2 + 1)/2\]</p>with <span>$\bar{x}$</span> the sample mean and <span>$s^2$</span> the sample variance. This estimator only exists if the true distribution <code>ξ</code> value is &lt; 0.5.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/FractalDimensions.jl/blob/7b30942fd79eac6eada169f51f59f623662d0782/src/extremes_based/extremesdim.jl#L158-L180">source</a></section></article><h2 id="Theiler-window"><a class="docs-heading-anchor" href="#Theiler-window">Theiler window</a><a id="Theiler-window-1"></a><a class="docs-heading-anchor-permalink" href="#Theiler-window" title="Permalink"></a></h2><p>The Theiler window is a concept that is useful when finding neighbors in a dataset that is coming from the sampling of a continuous dynamical system. Itt tries to eliminate spurious &quot;correlations&quot; (wrongly counted neighbors) due to a potentially dense sampling of the trajectory. Typically a good choice for <code>w</code> coincides with the choice an optimal delay time, see <code>DelayEmbeddings.estimate_delay</code>, for any of the timeseries of the dataset.</p><p>For more details, see Chapter 5 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p><h2 id="StateSpaceSet-reference"><a class="docs-heading-anchor" href="#StateSpaceSet-reference"><code>StateSpaceSet</code> reference</a><a id="StateSpaceSet-reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.StateSpaceSet" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T} &lt;: AbstractStateSpaceSet{D,T}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>. Each point is represented by <code>SVector{D, T}</code>. The data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(ssset::StateSpaceSet)</code>. Typically the order of points in the set is the time direction, but it doesn&#39;t have to be.</p><p>When indexed with 1 index, <code>StateSpaceSet</code> is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.</p><p><code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.standardize" href="#StateSpaceSets.standardize"><code>StateSpaceSets.standardize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standardize(d::StateSpaceSet) → r</code></pre><p>Create a standardized version of the input set where each column is transformed to have mean 0 and standard deviation 1.</p></div></section><section><div><pre><code class="nohighlight hljs">standardize(x::AbstractVector{&lt;:Real}) = (x - mean(x))/std(x)</code></pre></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Molteno1993"><a class="tag is-link" href="#citeref-Molteno1993">Molteno1993</a>Molteno, T. C. A., <a href="https://doi.org/10.1103/PhysRevE.48.R3263">Fast O(N) box-counting algorithm for estimating dimensions. Phys. Rev. E 48, R3263(R) (1993)</a></li><li class="footnote" id="footnote-Grassberger1983"><a class="tag is-link" href="#citeref-Grassberger1983">Grassberger1983</a>Grassberger and Proccacia, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.50.346">Characterization of strange attractors, PRL 50 (1983) </a></li><li class="footnote" id="footnote-Theiler1986"><a class="tag is-link" href="#citeref-Theiler1986">Theiler1986</a>Theiler, <a href="https://doi.org/10.1103/PhysRevA.34.2427">Spurious dimension from correlation algorithms applied to limited time-series data. Physical Review A, 34</a></li><li class="footnote" id="footnote-Grassberger2007"><a class="tag is-link" href="#citeref-Grassberger2007">Grassberger2007</a>Peter Grassberger (2007) <a href="http://dx.doi.org/10.4249/scholarpedia.3043">Grassberger-Procaccia algorithm. Scholarpedia, 2(5):3043.</a></li><li class="footnote" id="footnote-Kantz2003"><a class="tag is-link" href="#citeref-Kantz2003">Kantz2003</a>Kantz, H., &amp; Schreiber, T. (2003). <a href="https://doi.org/10.1017/CBO9780511755798">Nonlinear Time Series Analysis, Cambridge University Press.</a></li><li class="footnote" id="footnote-Bueno2007"><a class="tag is-link" href="#citeref-Bueno2007">Bueno2007</a>Bueno-Orovio and Pérez-García, <a href="https://doi.org/10.1016/j.chaos.2006.03.043">Enhanced box and prism assisted algorithms for computing the correlation dimension. Chaos Solitons &amp; Fractrals, 34(5) </a></li><li class="footnote" id="footnote-Theiler1987"><a class="tag is-link" href="#citeref-Theiler1987">Theiler1987</a>Theiler, <a href="https://doi.org/10.1103/PhysRevA.36.4456">Efficient algorithm for estimating the correlation dimension from a set of discrete points. Physical Review A, 36</a></li><li class="footnote" id="footnote-Bueno2007"><a class="tag is-link" href="#citeref-Bueno2007">Bueno2007</a>Bueno-Orovio and Pérez-García, <a href="https://doi.org/10.1016/j.chaos.2006.03.043">Enhanced box and prism assisted algorithms for computing the correlation dimension. Chaos Solitons &amp; Fractrals, 34(5) </a></li><li class="footnote" id="footnote-Theiler1987"><a class="tag is-link" href="#citeref-Theiler1987">Theiler1987</a>Theiler, <a href="https://doi.org/10.1103/PhysRevA.36.4456">Efficient algorithm for estimating the correlation dimension from a set of discrete points. Physical Review A, 36</a></li><li class="footnote" id="footnote-Grassberger1983"><a class="tag is-link" href="#citeref-Grassberger1983">Grassberger1983</a>Grassberger and Proccacia, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.50.346">Characterization of strange attractors, PRL 50 (1983) </a></li><li class="footnote" id="footnote-Theiler1987"><a class="tag is-link" href="#citeref-Theiler1987">Theiler1987</a>Theiler, <a href="https://doi.org/10.1103/PhysRevA.36.4456">Efficient algorithm for estimating the correlation dimension from a set of discrete points. Physical Review A, 36</a></li><li class="footnote" id="footnote-Grassberger1983"><a class="tag is-link" href="#citeref-Grassberger1983">Grassberger1983</a>Grassberger and Proccacia, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.50.346">Characterization of strange attractors, PRL 50 (1983) </a></li><li class="footnote" id="footnote-Grassberger1988"><a class="tag is-link" href="#citeref-Grassberger1988">Grassberger1988</a>Peter Grassberger (1988) <a href="https://doi.org/10.1016/0375-9601(88)90193-4">Finite sample Corrections to Entropy and Dimension Estimates, Physics Letters A 128(6-7)</a></li><li class="footnote" id="footnote-Takens1985"><a class="tag is-link" href="#citeref-Takens1985">Takens1985</a>Takens, On the numerical determination of the dimension of an attractor, in: B.H.W. Braaksma, B.L.J.F. Takens (Eds.), Dynamical Systems and Bifurcations, in: Lecture Notes in Mathematics, Springer, Berlin, 1985, pp. 99–106.</li><li class="footnote" id="footnote-Theiler1988"><a class="tag is-link" href="#citeref-Theiler1988">Theiler1988</a>Theiler, <a href="https://doi.org/10.1016/0375-9601(88)91016-X">Lacunarity in a best estimator of fractal dimension. Physics Letters A, 133(4–5)</a></li><li class="footnote" id="footnote-Borovkova1999"><a class="tag is-link" href="#citeref-Borovkova1999">Borovkova1999</a>Borovkova et al., <a href="https://doi.org/10.1214/aoap/1029962747">Consistency of the Takens estimator for the correlation dimension. The Annals of Applied Probability, 9, 05 1999.</a></li><li class="footnote" id="footnote-Barlow"><a class="tag is-link" href="#citeref-Barlow">Barlow</a>Barlow, R., Statistics - A Guide to the Use of Statistical Methods in the Physical Sciences. Vol 29. John Wiley &amp; Sons, 1993</li><li class="footnote" id="footnote-Kaplan1970"><a class="tag is-link" href="#citeref-Kaplan1970">Kaplan1970</a>J. Kaplan &amp; J. Yorke, <em>Chaotic behavior of multidimensional difference equations</em>, Lecture Notes in Mathematics vol. <strong>730</strong>, Springer (1979)</li><li class="footnote" id="footnote-Higuchi1988"><a class="tag is-link" href="#citeref-Higuchi1988">Higuchi1988</a>Higuchi, <em>Approach to an irregular time series on the basis of the fractal theory</em>, <a href="www.doi.org/10.1016/0167-2789(88)90081-4">Physica D: Nonlinear Phenomena (1988)</a></li><li class="footnote" id="footnote-Lucarini2016"><a class="tag is-link" href="#citeref-Lucarini2016">Lucarini2016</a>Lucarini et al., <a href="https://www.wiley.com/en-gb/Extremes+and+Recurrence+in+Dynamical+Systems-p-9781118632192">Extremes and Recurrence in Dynamical Systems </a></li><li class="footnote" id="footnote-Caby2018"><a class="tag is-link" href="#citeref-Caby2018">Caby2018</a>Caby et al., <a href="https://doi.org/10.1016/j.physd.2019.06.009">Physica D 400 132143 </a></li><li class="footnote" id="footnote-Süveges2007"><a class="tag is-link" href="#citeref-Süveges2007">Süveges2007</a>Süveges. 2007. Likelihood estimation of the extremal index. Extremes, 10.1-2, 41-55, doi: 10.1007/s10687-007-0034-2</li><li class="footnote" id="footnote-Flavio2023"><a class="tag is-link" href="#citeref-Flavio2023">Flavio2023</a>Flavio et al., Stability of attractor local dimension estimates in non-Axiom A dynamical systems, <a href="https://hal.science/hal-04051659">preprint</a></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 10 May 2023 09:17">Wednesday 10 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
